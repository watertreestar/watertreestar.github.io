<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos上Docker的安装</title>
    <url>/2019/01/27/ckybpqxe20001d2nhai4tfu9h/</url>
    <content><![CDATA[<h2 id="Centos上Docker的安装"><a href="#Centos上Docker的安装" class="headerlink" title="Centos上Docker的安装"></a>Centos上Docker的安装</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><blockquote>
<p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定 </p>
</blockquote>
<p>我的系统版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# uname -a</span><br><span class="line">Linux localhost.localdomain 3.10.0-514.10.2.el7.x86_64 #1 SMP Fri Mar 3 00:04:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker \</span></span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<h3 id="使用yum安装依赖包"><a href="#使用yum安装依赖包" class="headerlink" title="使用yum安装依赖包"></a>使用yum安装依赖包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils \</span></span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2</span><br></pre></td></tr></table></figure>
<h3 id="添加Docker软件源"><a href="#添加Docker软件源" class="headerlink" title="添加Docker软件源"></a>添加Docker软件源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 官方源</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> $ sudo yum-config-manager \</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     --add-repo \</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure>
<h3 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum makecache fast</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce</span></span><br></pre></td></tr></table></figure>
<p>以上方式是使用<code>yum</code>来安装，还可以使用官方提供的自动化脚本来安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL get.docker.com -o get-docker.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sh get-docker.sh --mirror Aliyun   <span class="comment"># 执行后，docker-ce将安装到系统</span></span></span><br></pre></td></tr></table></figure>
<h3 id="启动Docker-ce"><a href="#启动Docker-ce" class="headerlink" title="启动Docker-ce"></a>启动Docker-ce</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker  <span class="comment"># 开机启动</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker   <span class="comment"># 启动docker-ce服务</span></span></span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 <code>Docker</code> 引擎通讯。只有<code>root</code>用户和<code>docker</code>组的用户才能够有权限。所以可以把非<code>root</code>用户加入到<code>docker</code>用户组中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker   # 创建docker用户组</span><br><span class="line">sudo usermod -aG docker $USER   # 当前用户加入docker组</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>重新登录后测试<code>docker</code>服务是否可以使用</p>
<p>我们现在使用<code>docker run hello-world</code>命令来启动一个容器，如果<code>hello-world</code>镜像在本地不存在，docker会自动到仓库去<code>pull</code></p>
<p>运行此命令后，会输出如下日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run hello-world</span><br><span class="line">Unable to find image 'hello-world:latest' locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete </span><br><span class="line">Digest: sha256:2557e3c07ed1e38f26e389462d03ed943586f744621577a99efb77324b0fe535</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>
<h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>由于国外的镜像拉取会比较慢，推荐使用国内的镜像源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/docker/daemon.json  <span class="comment"># 修改此文件</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加如下</span></span><br><span class="line">&#123;</span><br><span class="line">        "registry-mirrors": ["http://hub-mirror.c.163.com"]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl restart docker <span class="comment"># 重启docker服务</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>CopyOnWriteList揭秘</title>
    <url>/2018/12/12/ckybpqxe60003d2nhf49l0kar/</url>
    <content><![CDATA[<h2 id="Vector和SynchronizedList"><a href="#Vector和SynchronizedList" class="headerlink" title="Vector和SynchronizedList"></a>Vector和SynchronizedList</h2><p>ArrayList是用来代替Vector，Vector是线程安全的容器，因为它在方法上都加上了synchronized同步关键字</p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Object[] anArray)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, anArray, <span class="number">0</span>, elementCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Trims the capacity of this vector to be the vector's current</span></span><br><span class="line"><span class="comment"> * size. If the capacity of this vector is larger than its current</span></span><br><span class="line"><span class="comment"> * size, then the capacity is changed to equal the size by replacing</span></span><br><span class="line"><span class="comment"> * its internal data array, kept in the field &#123;<span class="doctag">@code</span> elementData&#125;,</span></span><br><span class="line"><span class="comment"> * with a smaller one. An application can use this operation to</span></span><br><span class="line"><span class="comment"> * minimize the storage of a vector.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (elementCount &lt; oldCapacity) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>而Collections.synchronizedList方法也是在方法内部加了synchronized关键字<br><img src="/2018/12/12/ckybpqxe60003d2nhf49l0kar/SynchronizedList对象.png" alt=""></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Vector vector = <span class="keyword">new</span> Vector();</span><br><span class="line">	vector.add(<span class="string">"a"</span>);</span><br><span class="line">	vector.add(<span class="string">"b"</span>);</span><br><span class="line">	vector.add(<span class="string">"c"</span>);</span><br><span class="line">	<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">		getLast(vector);</span><br><span class="line">	&#125;).start();</span><br><span class="line">	<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">		removeLast(vector);</span><br><span class="line">	&#125;).start();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">		getLast(vector);</span><br><span class="line">	&#125;).start();</span><br><span class="line">	<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">		removeLast(vector);</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeLast</span><span class="params">(Vector vector)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index  = vector.size() - <span class="number">1</span>;</span><br><span class="line">	vector.remove(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector vector)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index = vector.size() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> vector.get(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这样的代码可能会发生异常，线程在交替执行的时候，我们自己方法getLast和removeLast没有保证原子性</p>
<p>要解决以上问题也很简单，就是在我们自己写的方法中做同步处理，例如添加synchronized关键字，想下面示例这样：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeLast</span><span class="params">(Vector vector)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index  = vector.size() - <span class="number">1</span>;</span><br><span class="line">	vector.remove(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector vector)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index = vector.size() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> vector.get(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看遍历Vector集合的时候<br><img src="/2018/12/12/ckybpqxe60003d2nhf49l0kar/Vector遍历异常.png" alt=""></p>
<p>例如，遍历获取vector.size()为3，当其他线程对容器做了修改后，此时容器的size为2，遍历获取get(3)就会出现异常</p>
<p>如果使用for-each(迭代器)来做上面的操作，会抛出ConcurrentModificationException异常</p>
<p><img src="/2018/12/12/ckybpqxe60003d2nhf49l0kar/foreach遍历异常.png" alt=""></p>
<p>要解决这个问题，也是在遍历方法对vector加锁</p>
<h2 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h2><p>一般来说，我们会认为：CopyOnWriteArrayList是同步List的替代品，CopyOnWriteArraySet是同步Set的替代品</p>
<p>无论是Hashtable到ConcurrentHashMap，Vector到CopyOnWriteArrayList。<br>JUC下支持并发的容器与老一代的线程安全类相比，都是在做锁粒度的优化</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>什么是COW</p>
<blockquote>
<p>如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，<br>直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，<br>而其他调用者所见到的最初的资源仍然保持不变。<br>优点是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作时可以共享同一份资源。</p>
</blockquote>
<p>看看CopyOnWriteArrayList中的数据结构<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment"> * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据结构比起ConcurrentHashMap来说很简单,使用Lock来上锁（修改数据的时候），使用Object数组来保持数据</p>
<p>CopyOnWriteArrayList的特点</p>
<ul>
<li>CopyOnWriteArrayList是线程安全容器(相对于ArrayList)，底层通过复制数组的方式来实现。</li>
<li>CopyOnWriteArrayList在遍历的使用不会抛出ConcurrentModificationException异常，并且遍历的时候就不用额外加锁</li>
<li>元素可以为null</li>
</ul>
<h3 id="揭秘"><a href="#揭秘" class="headerlink" title="揭秘"></a>揭秘</h3><p>CopyOnWriteList如果做到并发环境下遍历容器而不发生异常呢？</p>
<p>接下来我们看看iterator方法，该方法返回的是COWIterator类。我们可以看看这个类是怎么组成的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException always; &#123;<span class="doctag">@code</span> remove&#125;</span></span><br><span class="line"><span class="comment">     *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException always; &#123;<span class="doctag">@code</span> set&#125;</span></span><br><span class="line"><span class="comment">     *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Not supported. Always throws UnsupportedOperationException.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException always; &#123;<span class="doctag">@code</span> add&#125;</span></span><br><span class="line"><span class="comment">     *         is not supported by this iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        Object[] elements = snapshot;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = elements.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cursor; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) elements[i];</span><br><span class="line">            action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到类中有一个 Object[] snapshot这样的数组，根据代码可以直到这个数组保持的是待遍历的数组，对应的的就是CopyOnWriteArrayList中<br>保存数据的数组</p>
<p>由上我们可以知道，迭代器中保存的是获取CopyOnWriteList集合迭代器时的数据。所以在迭代过程中修改原来集合的数据不会影响到迭代器的遍历，所以CopyOnWriteList不能保证数据的实时一致性。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>DelayQueue延迟队列</title>
    <url>/2018/11/30/ckybpqxe80005d2nh1beg12te/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>DelayQueue 是一个支持延时获取元素的阻塞队列，<br>内部采用优先队列 PriorityQueue 存储元素，<br>同时元素必须实现 Delayed 接口；在创建元素时可以指定多久才可以从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>缓存系统：当能够从延迟队列DelayQueue中获取到元素时，说明缓存已经过期</li>
<li>定时任务调度：一分钟后发送短信</li>
</ul>
<a id="more"></a>
<h3 id="基于延迟队列，实现一个缓存系统"><a href="#基于延迟队列，实现一个缓存系统" class="headerlink" title="基于延迟队列，实现一个缓存系统"></a>基于延迟队列，实现一个缓存系统</h3><p>延迟队列中添加的元素，实现了Delayed接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheItem</span> <span class="keyword">implements</span> <span class="title">Delayed</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> expireTime;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> currentTime;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String key;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CacheItem</span><span class="params">(String key,<span class="keyword">long</span> expireTime)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">		<span class="keyword">this</span>.expireTime = expireTime;</span><br><span class="line">		<span class="keyword">this</span>.currentTime = System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 比较方法，用于排序</span></span><br><span class="line"><span class="comment">	 * 过期时间长的放队尾，时间短的放队首</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MICROSECONDS) &gt; o.getDelay(TimeUnit.MICROSECONDS))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.getDelay(TimeUnit.MICROSECONDS) &gt; o.getDelay(TimeUnit.MICROSECONDS))</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算剩余的过期时间</span></span><br><span class="line"><span class="comment">	 * 大于0说明没有过期</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> expireTime - unit.MILLISECONDS.toSeconds(System.currentTimeMillis()-currentTime);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>缓存实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Map&lt;String,String&gt; itemMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">private</span> DelayQueue&lt;CacheItem&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 初始化后就开始检测</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Cache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key,String value,<span class="keyword">long</span> expireTime)</span> </span>&#123;</span><br><span class="line">			CacheItem item = <span class="keyword">new</span> CacheItem(key,expireTime);</span><br><span class="line">			itemMap.put(key, value);</span><br><span class="line">			delayQueue.add(item);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> itemMap.get(key);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			stop = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 开启多线程，检测缓存是否过期</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(!stop) &#123;</span><br><span class="line">				CacheItem item = delayQueue.poll();</span><br><span class="line">				<span class="keyword">if</span>(item != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 缓存过期</span></span><br><span class="line">					 itemMap.remove(item.getKey());</span><br><span class="line">					 System.out.println(<span class="string">"delete expired key:"</span>+item.getKey());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"Cache stop"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Cache cache = <span class="keyword">new</span> Cache();</span><br><span class="line">		cache.add(<span class="string">"a"</span>, <span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line">		cache.add(<span class="string">"b"</span>, <span class="string">"2"</span>, <span class="number">2</span>);</span><br><span class="line">		cache.add(<span class="string">"c"</span>, <span class="string">"3"</span>, <span class="number">2</span>);</span><br><span class="line">		cache.add(<span class="string">"d"</span>, <span class="string">"4"</span>, <span class="number">4</span>);</span><br><span class="line">		cache.add(<span class="string">"e"</span>, <span class="string">"5"</span>, <span class="number">6</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			String a = cache.get(<span class="string">"a"</span>);</span><br><span class="line">			String b = cache.get(<span class="string">"b"</span>);</span><br><span class="line">			String c = cache.get(<span class="string">"c"</span>);</span><br><span class="line">			String d = cache.get(<span class="string">"d"</span>);</span><br><span class="line">			String e = cache.get(<span class="string">"e"</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(a == <span class="keyword">null</span> &amp;&amp; b == <span class="keyword">null</span> &amp;&amp; c == <span class="keyword">null</span> &amp;&amp; d == <span class="keyword">null</span> &amp;&amp; e == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		cache.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="延迟队列实现原理部分说明"><a href="#延迟队列实现原理部分说明" class="headerlink" title="延迟队列实现原理部分说明"></a>延迟队列实现原理部分说明</h3><ul>
<li>可重入锁 <code>ReentrantLock</code></li>
<li>优先队列 <code>PriorityQueue</code></li>
</ul>
<p>参考连接<a href="https://juejin.im/post/5bf945b95188254e2a04329b" target="_blank" rel="noopener"></a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-m3u8下载器(一)</title>
    <url>/2021/05/01/ckybpqxe90007d2nh4stx15yl/</url>
    <content><![CDATA[<h1 id="m3u8下载器"><a href="#m3u8下载器" class="headerlink" title="m3u8下载器"></a>m3u8下载器</h1><p>使用golang实现m3u8视频文件的下载</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是m3u8，接触过直播的人应该知道，HLS作为一种拉流的传输协议，我们时常也可以在浏览器上看到直播，这种使用了HLS，也就通过HTTP来传输HLS文件。</p>
<p>在一些小电影，电视剧的网站上，我们也可以发现他的踪迹。浏览器F12打开开发者工具，网络面板中看到一直有连续的ts文件请求，就是它了</p>
<a id="more"></a>
<p>M3U8 —— Unicode 版本的 M3U（Moving Picture Experts Group Audio Layer 3 Uniform Resource Locator），<br>使用了 UTF-8 编码，是 HLS（HTTP Living Stream，苹果公司基于 HTTP 实现的媒体流传输协议）协议的一部分，作为媒体文件描述清单，另外一部分为 TS（Transport Stream，传输流） 媒体文件。</p>
<p>M3U8 文件使用特定标签描述了媒体流的详细信息，包括时长、版本、编码、音频、字幕、播放列表、加密等。M3U8 媒体播放列表中保存了 TS 媒体文件的路径列表</p>
<p>例如，一个m3u8文件：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#EXTM3U</span></span><br><span class="line"><span class="meta">#EXT-X-VERSION:3</span></span><br><span class="line"><span class="meta">#EXT-X-TARGETDURATION:8</span></span><br><span class="line"><span class="meta">#EXT-X-MEDIA-SEQUENCE:0</span></span><br><span class="line"><span class="meta">#EXTINF:5.004,</span></span><br><span class="line">/<span class="number">20190319</span>/DnYZi3eA/<span class="number">800</span>kb/hls/imaOxa8299000.ts</span><br><span class="line"><span class="meta">#EXTINF:4.17,</span></span><br><span class="line">/<span class="number">20190319</span>/DnYZi3eA/<span class="number">800</span>kb/hls/imaOxa8299001.ts</span><br><span class="line"><span class="meta">#EXTINF:6.005,</span></span><br></pre></td></tr></table></figure>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>那么，在开始编码前，我们要知道一个m3u8文件的构成:</p>
<h3 id="1-m3u8类型"><a href="#1-m3u8类型" class="headerlink" title="1. m3u8类型"></a>1. m3u8类型</h3><p>当 M3U8 文件作为媒体播放列表（Media Playlist）时，其内部信息记录的是一系列媒体片段资源，顺序播放该片段资源，即可完整展示多媒体资源。其格式如下所示</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#EXTM3U</span></span><br><span class="line"><span class="meta">#EXT-X-TARGETDURATION:10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#EXTINF:9.009,</span></span><br><span class="line">http:<span class="comment">//media.example.com/first.ts</span></span><br><span class="line"><span class="meta">#EXTINF:9.009,</span></span><br><span class="line">http:<span class="comment">//media.example.com/second.ts</span></span><br><span class="line"><span class="meta">#EXTINF:3.003,</span></span><br><span class="line">http:<span class="comment">//media.example.com/third.ts</span></span><br><span class="line"><span class="meta">#EXT-X-ENDLIST</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有些 TS 文件是经过加密处理的，下载下来无法直接播放，需要对 TS 数据进行解密，METHOD 为加密方式，一般为 AES-128 或者 NONE。如果为 AES-128 则有 URI 给定秘钥的存放位置，<br>部分加密还是用了 IV 偏移向量，因此在解密的时候需要格外注意，记得一起使用 IV 来进行解密。如果 METHOD 为 NONE 则表示没有加密，默认可以不声明 #EXT-X-KEY，NONE 的情况下不能出现 URI 和 IV</p>
</blockquote>
<p>当 M3U8 作为主播放列表（Master Playlist）时，其内部提供的是同一份媒体资源的多份流列表资源。其格式如下所示：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#EXTM3U</span></span><br><span class="line"><span class="meta">#EXT-X-STREAM-INF:BANDWIDTH=150000,RESOLUTION=416x234,CODECS=<span class="string">"avc1.42e00a,mp4a.40.2"</span></span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//example.com/low/index.m3u8</span></span><br><span class="line"><span class="meta">#EXT-X-STREAM-INF:BANDWIDTH=240000,RESOLUTION=416x234,CODECS=<span class="string">"avc1.42e00a,mp4a.40.2"</span></span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//example.com/lo_mid/index.m3u8</span></span><br><span class="line"><span class="meta">#EXT-X-STREAM-INF:BANDWIDTH=440000,RESOLUTION=416x234,CODECS=<span class="string">"avc1.42e00a,mp4a.40.2"</span></span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//example.com/hi_mid/index.m3u8</span></span><br><span class="line"><span class="meta">#EXT-X-STREAM-INF:BANDWIDTH=640000,RESOLUTION=640x360,CODECS=<span class="string">"avc1.42e00a,mp4a.40.2"</span></span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//example.com/high/index.m3u8</span></span><br><span class="line"><span class="meta">#EXT-X-STREAM-INF:BANDWIDTH=64000,CODECS=<span class="string">"mp4a.40.5"</span></span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//example.com/audio/index.m3u8</span></span><br><span class="line"><span class="meta">#EXT-X-ENDLIST</span></span><br></pre></td></tr></table></figure>
<h3 id="2-m3u8的基本属性"><a href="#2-m3u8的基本属性" class="headerlink" title="2. m3u8的基本属性"></a>2. m3u8的基本属性</h3><ul>
<li>#EXTM3U                    M3U8文件头，必须放在第一行;</li>
<li>#EXT-X-MEDIA-SEQUENCE      第一个TS分片的序列号，一般情况下是0，但是在直播场景下，这个序列号标识直播段的起始位置; #EXT-X-MEDIA-SEQUENCE:0</li>
<li>#EXT-X-TARGETDURATION      每个分片TS的最大的时长;   #EXT-X-TARGETDURATION:10     每个分片的最大时长是 10s</li>
<li>#EXT-X-ALLOW-CACHE         是否允许cache;          #EXT-X-ALLOW-CACHE:YES      #EXT-X-ALLOW-CACHE:NO    默认情况下是YES</li>
<li>#EXT-X-ENDLIST             M3U8文件结束符；</li>
<li>#EXTINF                    extra info，分片TS的信息，如时长，带宽等；一般情况下是    #EXTINF:<code>&lt;duration&gt;</code>,[<code>&lt;title&gt;</code>] 后面可以跟着其他的信息，逗号之前是当前分片的ts时长，分片时长 移动要小于 #EXT-X-TARGETDURATION 定义的值；</li>
<li>#EXT-X-VERSION             M3U8版本号</li>
<li>#EXT-X-DISCONTINUITY       该标签表明其前一个切片与下一个切片之间存在中断。下面会详解</li>
<li>#EXT-X-PLAYLIST-TYPE       表明流媒体类型；</li>
<li>#EXT-X-KEY                 是否加密解析，    #EXT-X-KEY:METHOD=AES-128,URI=”<a href="https://priv.example.com/key.php?r=52" target="_blank" rel="noopener">https://priv.example.com/key.php?r=52</a>“    加密方式是AES-128,秘钥需要请求   <a href="https://priv.example.com/key.php?r=52" target="_blank" rel="noopener">https://priv.example.com/key.php?r=52</a>  ，请求回来存储在本地；</li>
</ul>
<h3 id="3-怎么判断是否是m3u8直播"><a href="#3-怎么判断是否是m3u8直播" class="headerlink" title="3. 怎么判断是否是m3u8直播"></a>3. 怎么判断是否是m3u8直播</h3><p>1.判断是否存在 #EXT-X-ENDLIST<br>对于一个M3U8文件，如果结尾不存在 #EXT-X-ENDLIST，那么一定是 直播，不是点播；</p>
<p>2.判断 #EXT-X-PLAYLIST-TYPE 类型</p>
<p>#EXT-X-PLAYLIST-TYPE 有两种类型：</p>
<ul>
<li>VOD 即 Video on Demand，表示该视频流为点播源，因此服务器不能更改该 M3U8 文件；</li>
<li>EVENT 表示该视频流为直播源，因此服务器不能更改或删除该文件任意部分内容（但是可以在文件末尾添加新内容）<br>（注：VOD 文件通常带有 EXT-X-ENDLIST 标签，因为其为点播片源，不会改变；而 EVEVT 文件初始化时一般不会有 EXT-X-ENDLIST 标签，暗示有新的文件会添加到播放列表末尾，因此也需要客户端定时获取该 M3U8 文件，以获取新的媒体片段资源，直到访问到 EXT-X-ENDLIST 标签才停止）</li>
</ul>
<h3 id="4-多码率"><a href="#4-多码率" class="headerlink" title="4. 多码率"></a>4. 多码率</h3><p>例如一个master list中：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta">#EXTM3U</span></span><br><span class="line"><span class="meta">#EXT-X-STREAM-INF:BANDWIDTH=150000,RESOLUTION=416x234,CODECS=<span class="string">"avc1.42e00a,mp4a.40.2"</span></span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//example.com/low/index.m3u8</span></span><br><span class="line"><span class="meta">#EXT-X-STREAM-INF:BANDWIDTH=240000,RESOLUTION=416x234,CODECS=<span class="string">"avc1.42e00a,mp4a.40.2"</span></span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//example.com/lo_mid/index.m3u8</span></span><br><span class="line"><span class="meta">#EXT-X-STREAM-INF:BANDWIDTH=440000,RESOLUTION=416x234,CODECS=<span class="string">"avc1.42e00a,mp4a.40.2"</span></span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//example.com/hi_mid/index.m3u8</span></span><br><span class="line"><span class="meta">#EXT-X-STREAM-INF:BANDWIDTH=640000,RESOLUTION=640x360,CODECS=<span class="string">"avc1.42e00a,mp4a.40.2"</span></span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//example.com/high/index.m3u8</span></span><br><span class="line"><span class="meta">#EXT-X-STREAM-INF:BANDWIDTH=64000,CODECS=<span class="string">"mp4a.40.5"</span></span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//example.com/audio/index.m3u8</span></span><br><span class="line"><span class="meta">#EXT-X-ENDLIST</span></span><br></pre></td></tr></table></figure>
<p>通过不同码率选择上面不同的m3u8文件，然后在获取ts片段</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>根据上面的内容，我们在心里可以大概有一个m3u8文件的结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210529132616827.png" alt="image-20210529132616827"></p>
<p>接下来的代码实现中也会创建对应的数据结构,我们需要从string或者io流中解析出上述的结构，以便进行后续的操作</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>m3u8</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-m3u8下载器(二)</title>
    <url>/2021/05/05/ckybpqxe90008d2nhhz1agusv/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇中分析了一个m3u8文件的包含的属性，今天来通过代码来表示出这个数据结构并实现下载</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-数据结构定义"><a href="#1-数据结构定义" class="headerlink" title="1. 数据结构定义"></a>1. 数据结构定义</h3><p>上一篇定义出了一个m3u8文件的结构，那我们现在就从这个文件中读取出计算机能够识别的结构。</p>
<a id="more"></a>
<p>这个文件的parse非常简单，不涉及到复杂的语法，现在我们需要覆盖的范围也就只是上一篇提到的几个，所以关键字也没有几个。那么我们就可以按行读取出来，<br>每一行就是一个字符串，根据这个字符串的头部来判断是一个什么结构，读取的过程中顺便判断这个文件是不是合法的，很容易。</p>
<p>首先我们需要一个struct来表示一个m3u8文件<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> M3u8 <span class="keyword">struct</span> &#123;</span><br><span class="line">	Version        <span class="keyword">int8</span>              <span class="comment">// EXT-X-VERSION:version</span></span><br><span class="line">	MediaSequence  <span class="keyword">uint64</span>            <span class="comment">// Default 0, #EXT-X-MEDIA-SEQUENCE:sequence</span></span><br><span class="line">	Segments       []*Segment        <span class="comment">// Define a Play List</span></span><br><span class="line">	MasterPlaylist []*MasterPlaylist <span class="comment">// Define a Master Play List</span></span><br><span class="line">	Keys           <span class="keyword">map</span>[<span class="keyword">int</span>]*Key      <span class="comment">// Keys for per segment</span></span><br><span class="line">	EndList        <span class="keyword">bool</span>              <span class="comment">// #EXT-X-ENDLIST</span></span><br><span class="line">	PlaylistType   PlaylistType      <span class="comment">// VOD or EVENT</span></span><br><span class="line">	TargetDuration <span class="keyword">float64</span>           <span class="comment">// #EXT-X-TARGETDURATION:duration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面看到有Segment和MasterPlayList,这两个二选一，也就是上篇说的一个m3u8可以是一个MasterPlayList来提供多码率，从MasterPalyList中可以选择一个<br>特定的码率，然后拿到一个新的m3u8文件，这个m3u8中包含了多个Segment，Segment包含了ts片段（也就是一个代表ts的URI）.还看到一个Key数组，这个是对于每一个<br>Segment的加密密钥</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Segment</span></span><br><span class="line"><span class="comment">// #EXTINF:10.000000,</span></span><br><span class="line"><span class="comment">// 5dd92bfb879c6421d7281c769f0f8c93-4.ts</span></span><br><span class="line"><span class="keyword">type</span> Segment <span class="keyword">struct</span> &#123;</span><br><span class="line">	URI      <span class="keyword">string</span></span><br><span class="line">	KeyIndex <span class="keyword">int</span></span><br><span class="line">	Title    <span class="keyword">string</span>  <span class="comment">// #EXTINF: duration,&lt;title&gt;</span></span><br><span class="line">	Duration <span class="keyword">float32</span> <span class="comment">// #EXTINF: duration,&lt;title&gt;</span></span><br><span class="line">	Length   <span class="keyword">uint64</span>  <span class="comment">// #EXT-X-BYTERANGE: length[@offset]</span></span><br><span class="line">	Offset   <span class="keyword">uint64</span>  <span class="comment">// #EXT-X-BYTERANGE: length[@offset]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MasterPlaylist</span></span><br><span class="line"><span class="comment">// #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=240000,RESOLUTION=416x234,CODECS="avc1.42e00a,mp4a.40.2"</span></span><br><span class="line"><span class="keyword">type</span> MasterPlaylist <span class="keyword">struct</span> &#123;</span><br><span class="line">	URI        <span class="keyword">string</span></span><br><span class="line">	BandWidth  <span class="keyword">uint32</span></span><br><span class="line">	Resolution <span class="keyword">string</span></span><br><span class="line">	Codecs     <span class="keyword">string</span></span><br><span class="line">	ProgramID  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Key</span></span><br><span class="line"><span class="comment">// #EXT-X-KEY:METHOD=AES-128,URI="key.key"</span></span><br><span class="line"><span class="keyword">type</span> Key <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 'AES-128' or 'NONE'</span></span><br><span class="line">	<span class="comment">// If the encryption method is NONE, the URI and the IV attributes MUST NOT be present</span></span><br><span class="line">	Method CryptMethod</span><br><span class="line">	URI    <span class="keyword">string</span></span><br><span class="line">	IV     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-parser"><a href="#2-parser" class="headerlink" title="2. parser"></a>2. parser</h3><p>定义好这个结构后，就需要从文件中解析出这个结构，我们要做的就是从一个文件中读取一行，把这一行作为字符串，判断字符串的头部是什么开始的，如果匹配上了，就进一步处理<br>比如我们遇到一行<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#EXTINF</span><span class="selector-pseudo">:10.000000</span>,<span class="selector-tag">hello</span></span><br></pre></td></tr></table></figure><br>我们就可以认为这是一个segment的的duration和title定义,那么我们就可以按照以下的方式来解析<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> strings.HasPrefix(line, <span class="string">"#EXTINF:"</span>):</span><br><span class="line">    <span class="keyword">if</span> extInf &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"duplicate EXTINF: %s, line: %d"</span>, line, i+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> seg == <span class="literal">nil</span> &#123;</span><br><span class="line">        seg = <span class="built_in">new</span>(Segment)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> _, err := fmt.Sscanf(line, <span class="string">"#EXTINF:%s"</span>, &amp;s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> strings.Contains(s, <span class="string">","</span>) &#123;</span><br><span class="line">        split := strings.Split(s, <span class="string">","</span>)</span><br><span class="line">        seg.Title = split[<span class="number">1</span>]</span><br><span class="line">        s = split[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    df, err := strconv.ParseFloat(s, <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    seg.Duration = <span class="keyword">float32</span>(df)</span><br><span class="line">    seg.KeyIndex = keyIndex</span><br><span class="line">    extInf = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>整个parse过程就类似于上面这种，通过for + switch-case 来实现。其实就是一个简单的词法分析器，由于这里我们没有做语法分析，所以对于错误我们不能发现。<br>更加完善的词法分析可以了解编译原理的知识，或者通过有限自动机来实现</p>
<h3 id="3-download"><a href="#3-download" class="headerlink" title="3. download"></a>3. download</h3><p>完成分析，构造出我们要的结构以后，就可以来进行下载了，通过http请求，然后保存每一个ts片段，最后我们把所有的ts片段合并成一个文件便完成了下载。<br>为了加快下载的速度，当然不能少了协程</p>
<p>关键下载的代码：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    tsIdx, end, err := d.next()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> end &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">if</span> err := d.download(idx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Back into the queue, retry request</span></span><br><span class="line">            fmt.Printf(<span class="string">"[failed] %s\n"</span>, err.Error())</span><br><span class="line">            <span class="keyword">if</span> err := d.back(idx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(err.Error())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(tsIdx)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="keyword">if</span> err := d.merge(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure></p>
<p>这个工具整体来说比较简单，这里这是提供一种思路，本身就很容易通过任何一门语言来实现</p>
<p>在做这个过程中，我也参考了别人的思路和代码。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>m3u8</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap中的writeObject和readObject?</title>
    <url>/2018/08/17/ckybpqxea0009d2nhbvbthz68/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>HashMap中有两个私有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStrem oos)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>两个方法都是私有方法</li>
<li>HashMap内部不调用此方法</li>
</ul>
<a id="more"></a>
<h4 id="为什么会存在这两个方法"><a href="#为什么会存在这两个方法" class="headerlink" title="为什么会存在这两个方法"></a>为什么会存在这两个方法</h4><h5 id="这两个方法的作用是什么"><a href="#这两个方法的作用是什么" class="headerlink" title="这两个方法的作用是什么"></a>这两个方法的作用是什么</h5><p><code>writeObject</code>和<code>readObject</code>方法都是为了我<code>HashMap</code>的序列化而创建的</p>
<p><code>HashMap</code>实现了<code>Serializable</code>接口，这表明该类可以被序列化，而JDK中提供序列化的类是<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>.</p>
<p><code>ObjectOutputStream</code>提供了<code>writeObject</code>方法来序列化自定义类</p>
<p>查看<code>writeObject</code>方法的内部实现可知，方法内会判断序列化的对象内部是否实现了<code>writeObject</code>方法，如果实现了就调用此方法，没有实现就调用默认的序列化方法</p>
<h4 id="为什么HashMap要自己实现writeObject和readObject方法，而不是使用JDK统一的默认序列化和反序列化操作呢？"><a href="#为什么HashMap要自己实现writeObject和readObject方法，而不是使用JDK统一的默认序列化和反序列化操作呢？" class="headerlink" title="为什么HashMap要自己实现writeObject和readObject方法，而不是使用JDK统一的默认序列化和反序列化操作呢？"></a>为什么HashMap要自己实现writeObject和readObject方法，而不是使用JDK统一的默认序列化和反序列化操作呢？</h4><p>首先要明确序列化的目的，将java对象序列化，一定是为了在某个时刻能够将该对象反序列化，而且一般来讲序列化和反序列化所在的机器是不同的，因为序列化最常用的场景就是跨机器的调用（把对象转化为字节流，才能进行网络传输），而序列化和反序列化的一个最基本的要求就是，反序列化之后的对象与序列化之前的对象是一致的。</p>
<p>HashMap中，由于Entry的存放位置是根据Key的Hash值来计算，然后存放到数组中的，对于同一个Key，在不同的JVM实现中计算得出的Hash值可能是不同的。</p>
<p>Hash值不同导致的结果就是：有可能一个HashMap对象的反序列化结果与序列化之前的结果不一致。即有可能序列化之前，Key=’AAA’的元素放在数组的第0个位置，而反序列化值后，根据Key获取元素的时候，可能需要从数组为2的位置来获取，而此时获取到的数据与序列化之前肯定是不同的。 </p>
<p>所以为了避免这个问题，HashMap采用了下面的方式来解决：</p>
<ol>
<li>将可能会造成数据不一致的元素使用transient关键字修饰，从而避免JDK中默认序列化方法对该对象的序列化操作。不序列化的包括：Entry[ ] table,size,modCount。</li>
<li>自己实现writeObject方法，从而保证序列化和反序列化结果的一致性。</li>
</ol>
<h4 id="那么，HashMap又是通过什么手段来保证序列化和反序列化数据的一致性的呢"><a href="#那么，HashMap又是通过什么手段来保证序列化和反序列化数据的一致性的呢" class="headerlink" title="那么，HashMap又是通过什么手段来保证序列化和反序列化数据的一致性的呢"></a>那么，HashMap又是通过什么手段来保证序列化和反序列化数据的一致性的呢</h4><ol>
<li>首先，HashMap序列化的时候不会将保存数据的数组序列化，而是将元素个数以及每个元素的Key和Value都进行序列化。</li>
<li>在反序列化的时候，重新计算Key和Value的位置，重新填充一个数组。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis动态SQL和缓存</title>
    <url>/2018/08/05/ckybpqxeb000ad2nhbhtp5fy3/</url>
    <content><![CDATA[<h4 id="1-什么是动态SQL"><a href="#1-什么是动态SQL" class="headerlink" title="1.  什么是动态SQL"></a>1.  什么是动态SQL</h4><p>静态SQL：静态SQL语句在程序运行前SQL语句必须是确定的，SQL语句中涉及的表的字段名必须是存在的，静态SQL的编译是在程序运行前的。</p>
<p>动态SQL：动态SQL语句是在程序运行是被创建和执行的。</p>
<a id="more"></a>
<h4 id="2-MyBatis中的动态SQL"><a href="#2-MyBatis中的动态SQL" class="headerlink" title="2. MyBatis中的动态SQL"></a>2. MyBatis中的动态SQL</h4><p>为什么需要动态SQL?有时候需要根据实际传入的参数来动态的拼接SQL语句。</p>
<p>对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在,此时就需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句</p>
<p>MyBatis中用于实现动态SQL的元素主要有： </p>
<ul>
<li>if </li>
<li>choose / when / otherwise </li>
<li>trim </li>
<li>where </li>
<li>set </li>
</ul>
<ul>
<li>foreach</li>
</ul>
<h4 id="3-if标签"><a href="#3-if标签" class="headerlink" title="3. if标签"></a>3. if标签</h4><h4 id="4-choose标签"><a href="#4-choose标签" class="headerlink" title="4. choose标签"></a>4. choose标签</h4><h4 id="5-trim标签"><a href="#5-trim标签" class="headerlink" title="5. trim标签"></a>5. trim标签</h4><h4 id="6-set标签"><a href="#6-set标签" class="headerlink" title="6. set标签"></a>6. set标签</h4><h4 id="7-foreach标签"><a href="#7-foreach标签" class="headerlink" title="7. foreach标签"></a>7. foreach标签</h4><p>动态SQL的另一个常用的操作是需要对一个集合进行遍历，通常在构建in条件语句的时候</p>
<p>foreach标签还可以用于批量保存数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmps"</span>&gt;</span></span><br><span class="line">INSERT INTO tbl_employee(user_name,gender,email,d_id) VALUES</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"emps"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">(#&#123;emp.userName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.depart.id&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">EmployeeMapper mapper = openSession.getMapper(EmployeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">List&lt;Employee&gt; emps = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">emps.add(<span class="keyword">new</span> Employee(<span class="number">0</span>, <span class="number">1</span>, <span class="string">"allen"</span>, <span class="string">"allen@163.com"</span>, <span class="keyword">new</span> Department(<span class="number">1</span>)));</span><br><span class="line">emps.add(<span class="keyword">new</span> Employee(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"tom"</span>, <span class="string">"tom@163.com"</span>, <span class="keyword">new</span> Department(<span class="number">2</span>)));</span><br><span class="line">emps.add(<span class="keyword">new</span> Employee(<span class="number">0</span>, <span class="number">1</span>, <span class="string">"mux"</span>, <span class="string">"mux@163.com"</span>, <span class="keyword">new</span> Department(<span class="number">1</span>)));</span><br><span class="line">mapper.addEmps(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#### </p>
<h4 id="8-MyBatis缓存机制"><a href="#8-MyBatis缓存机制" class="headerlink" title="8. MyBatis缓存机制"></a>8. MyBatis缓存机制</h4><p>MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。缓存可以极大的提升查询效率。<br>MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存。</p>
<h5 id="1-gt-一级缓存"><a href="#1-gt-一级缓存" class="headerlink" title="1&gt;  一级缓存"></a>1&gt;  一级缓存</h5><p>SqlSession级别的缓存，默认是开启的，不能关闭。与数据库同一次会话期间查询到的数据放在本地缓存中</p>
<p>使用以下代码测试缓存一级缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EmployeeMapper mapper = openSession.getMapper(EmployeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Employee emp = mapper.getEmployeeById(<span class="number">2</span>);</span><br><span class="line">    System.out.println(emp);</span><br><span class="line">    Employee emp2 = mapper.getEmployeeById(<span class="number">2</span>);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line"></span><br><span class="line">    System.out.println(emp == emp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也有一级缓存失效的时候，此时就需要查询数据库</p>
<ul>
<li>SqlSession不同</li>
<li>SqlSession相同，查询条件不一致</li>
<li>SqlSession相同，查询条件一致，但在两次查询期间有增删改操作</li>
<li>SqlSession相同，手动清楚了一级缓存</li>
</ul>
<h5 id="2-gt-二级缓存"><a href="#2-gt-二级缓存" class="headerlink" title="2&gt;   二级缓存"></a>2&gt;   二级缓存</h5><p>基于namespace级别的缓存:一个namespace对应一个二级缓存</p>
<p>二级缓存可以跨越SqlSession</p>
<h5 id="3-gt-二级缓存的使用"><a href="#3-gt-二级缓存的使用" class="headerlink" title="3&gt;  二级缓存的使用"></a>3&gt;  二级缓存的使用</h5><ol>
<li><p>在MyBatis全局配置文件中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mapper配置文件中配置二级缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"FIFO"</span> <span class="attr">flushInterval</span>=<span class="string">"60000"</span> <span class="attr">readOnly</span>=<span class="string">"false"</span> <span class="attr">size</span>=<span class="string">"1024"</span> <span class="attr">type</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">eviction=“FIFO”：缓存回收策略：</span></span><br><span class="line"><span class="comment">LRU –最近最少使用的：移除最长时间不被使用的对象。</span></span><br><span class="line"><span class="comment">FIFO –先进先出：按对象进入缓存的顺序来移除它们。</span></span><br><span class="line"><span class="comment">SOFT –软引用：移除基于垃圾回收器状态和软引用规则的对象。</span></span><br><span class="line"><span class="comment">WEAK –弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</span></span><br><span class="line"><span class="comment">默认的是LRU。</span></span><br><span class="line"><span class="comment">flushInterval：缓存刷新间隔</span></span><br><span class="line"><span class="comment">缓存多长时间清空一次，默认不清空，设置一个毫秒值。</span></span><br><span class="line"><span class="comment">size：引用数目，正整数</span></span><br><span class="line"><span class="comment">代表缓存最多可以存储多少个对象，太大容易导致内存溢出</span></span><br><span class="line"><span class="comment">readOnly：是否只读，true/false   </span></span><br><span class="line"><span class="comment">true：只读缓存；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。</span></span><br><span class="line"><span class="comment">mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快。</span></span><br><span class="line"><span class="comment">false：非只读:mybatis觉得获取的数据可能会被修改。</span></span><br><span class="line"><span class="comment">mybatis会利用序列化&amp;反序列化的技术克隆一份。安全，速度慢。</span></span><br><span class="line"><span class="comment">type:指定自定义缓存的全类名</span></span><br><span class="line"><span class="comment">实现cache接口即可！</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis逆向工程</title>
    <url>/2018/08/05/ckybpqxeb000bd2nhawuf3url/</url>
    <content><![CDATA[<h4 id="什么是逆向工程"><a href="#什么是逆向工程" class="headerlink" title="什么是逆向工程"></a>什么是逆向工程</h4><p>MyBatis的一个主要的特点就是需要程序员自己编写sql，那么如果表太多的话，难免会很麻烦，所以mybatis官方提供了一个逆向工程，可以针对单表自动生成mybatis执行所需要的代码（包括mapper.xml、mapper.java、pojo）。一般在开发中，常用的逆向工程方式是通过数据库的表生成代码</p>
<a id="more"></a>
<h4 id="使用逆向工程生成代码"><a href="#使用逆向工程生成代码" class="headerlink" title="使用逆向工程生成代码"></a>使用逆向工程生成代码</h4><h5 id="1-新建一个工程"><a href="#1-新建一个工程" class="headerlink" title="1. 新建一个工程"></a>1. 新建一个工程</h5><p>使用Maven新建一个Java工程引入相应的包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.40<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-建立逆向工程配置文件"><a href="#2-建立逆向工程配置文件" class="headerlink" title="2. 建立逆向工程配置文件"></a>2. 建立逆向工程配置文件</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 有Example查询条件内容 --&gt;</span></span><br><span class="line">       	<span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"testTables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 (自己修改)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span></span></span><br><span class="line"><span class="tag">            <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">userId</span>=<span class="string">"cyp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">password</span>=<span class="string">"cyp"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL</span></span><br><span class="line"><span class="comment">            和 NUMERIC 类型解析为java.math.BigDecimal --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- targetProject:生成Entity类的路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetProject</span>=<span class="string">"./src/main/java"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetPackage</span>=<span class="string">"pojo"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- targetProject:XXXMapper.xml映射文件生成的路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetProject</span>=<span class="string">"./src/main/resources"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetPackage</span>=<span class="string">"mapper"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- targetPackage：Mapper接口生成的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">"./src/main/java"</span> <span class="attr">targetPackage</span>=<span class="string">"dao"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 数据库表名字和我们的entity类对应的映射指定(需自己修改) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user"</span> <span class="attr">domainObjectName</span>=<span class="string">"User"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"student"</span> <span class="attr">domainObjectName</span>=<span class="string">"Student"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"account"</span> <span class="attr">domainObjectName</span>=<span class="string">"Account"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 有些表的字段需要指定java类型 &lt;table schema="" tableName=""&gt; &lt;columnOverride column=""</span></span><br><span class="line"><span class="comment">            javaType="" /&gt; &lt;/table&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置文件中各个标签的作用已经在配置文件中注释</p>
<p>配置文件中POJO，mapper接口，mapper文件的包创建好</p>
<h5 id="3-新建工具类，用来加载配置文件和生成代码"><a href="#3-新建工具类，用来加载配置文件和生成代码" class="headerlink" title="3. 新建工具类，用来加载配置文件和生成代码"></a>3. 新建工具类，用来加载配置文件和生成代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.exception.XMLParserException;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载逆向生成配置文件，逆向生成代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WaterTree</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisGeneratorUtil</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generator</span><span class="params">()</span> <span class="keyword">throws</span> Exception, XMLParserException</span>&#123;</span><br><span class="line">		List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 指定逆向工程配置文件</span></span><br><span class="line">		File configurationFile = <span class="keyword">new</span> File(<span class="string">"generatorConfig.xml"</span>);</span><br><span class="line">		ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">		</span><br><span class="line">		Configuration configuration = cp.parseConfiguration(configurationFile);</span><br><span class="line">		DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(<span class="keyword">true</span>);</span><br><span class="line">		</span><br><span class="line">		MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(configuration, callback, warnings);</span><br><span class="line">		</span><br><span class="line">		myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-新建类包含mian方法调用工具类"><a href="#4-新建类包含mian方法调用工具类" class="headerlink" title="4. 新建类包含mian方法调用工具类"></a>4. 新建类包含mian方法调用工具类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.exception.XMLParserException;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载逆向生成配置文件，逆向生成代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> WaterTree</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisGeneratorUtil</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generator</span><span class="params">()</span> <span class="keyword">throws</span> Exception, XMLParserException</span>&#123;</span><br><span class="line">		List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 指定逆向工程配置文件</span></span><br><span class="line">		File configurationFile = <span class="keyword">new</span> File(<span class="string">"generatorConfig.xml"</span>);</span><br><span class="line">		ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">		</span><br><span class="line">		Configuration configuration = cp.parseConfiguration(configurationFile);</span><br><span class="line">		DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(<span class="keyword">true</span>);</span><br><span class="line">		</span><br><span class="line">		MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(configuration, callback, warnings);</span><br><span class="line">		</span><br><span class="line">		myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-运行后项目的结构"><a href="#5-运行后项目的结构" class="headerlink" title="5. 运行后项目的结构"></a>5. 运行后项目的结构</h5><p><img src="/2018/08/05/ckybpqxeb000bd2nhawuf3url/mybatis逆行工程项目结构.png" alt=""></p>
<h4 id="逆向工具生成的Example类"><a href="#逆向工具生成的Example类" class="headerlink" title="逆向工具生成的Example类"></a>逆向工具生成的Example类</h4><p>自定义查询条件的java类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		排序方式  字段 + 空格 + asc（desc）	</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">protected</span> String orderByClause;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	是否去重</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> distinct;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	查询条件   eg-&gt;   name = 'tom'</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Criteria&gt; oredCriteria;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        oredCriteria = <span class="keyword">new</span> ArrayList&lt;Criteria&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderByClause</span><span class="params">(String orderByClause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderByClause = orderByClause;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderByClause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderByClause;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDistinct</span><span class="params">(<span class="keyword">boolean</span> distinct)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.distinct = distinct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDistinct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distinct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Criteria&gt; <span class="title">getOredCriteria</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> oredCriteria;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">or</span><span class="params">(Criteria criteria)</span> </span>&#123;</span><br><span class="line">        oredCriteria.add(criteria);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 悲观锁和乐观锁</title>
    <url>/2019/03/04/ckybpqxec000cd2nhcp31597m/</url>
    <content><![CDATA[<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p>
<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。</p>
<a id="more"></a>
<h3 id="悲观锁-1"><a href="#悲观锁-1" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量 </p>
<blockquote>
<p> 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性 </p>
</blockquote>
<p> 乐观锁一般来说有以下2种方式：</p>
<ol>
<li>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</li>
<li>使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li>
</ol>
<p>Java JUC中的atomic包就是乐观锁的一种实现，AtomicInteger 通过CAS（Compare And Set）操作实现线程安全的自增。</p>
<p> MySQL InnoDB采用的是两阶段锁定协议（two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB会根据事务隔离级别在需要的时候自动加锁。</p>
<p>另外，InnoDB也支持通过特定的语句进行显示锁定，这些语句不属于SQL规范：</p>
<ul>
<li>SELECT … LOCK IN SHARE MODE</li>
<li>SELECT … FOR UPDATE</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>通过一个小案例展示乐观锁和悲观锁的使用</p>
<p>考虑电商秒杀系统中，如果保证商品不超买，要保证数据的一致性</p>
<p>假设一张商品表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_product(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    stock <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> </span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>
<p> 在不考虑并发的情况下，修改商品库存的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新库存(不考虑并发)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateStockRaw</span><span class="params">(Long productId)</span></span>&#123;</span><br><span class="line">    ProductStock product = query(<span class="string">"SELECT * FROM tb_product WHERE id=#&#123;productId&#125;"</span>, productId);</span><br><span class="line">    <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> updateCnt = update(<span class="string">"UPDATE tb_product SET stock=stock-1 WHERE id=#&#123;productId&#125;"</span>, productId);</span><br><span class="line">        <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方式在多线程并发的情况下可能会出现超卖问题。</p>
<p>下面演示使用悲观锁和乐观锁来解决这个问题。</p>
<h4 id="使用悲观锁"><a href="#使用悲观锁" class="headerlink" title="使用悲观锁"></a>使用悲观锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新库存(使用悲观锁)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateStock</span><span class="params">(Long productId)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先锁定商品库存记录</span></span><br><span class="line">    ProductStock product = query(<span class="string">"SELECT * FROM tb_product WHERE id=#&#123;productId&#125; FOR UPDATE"</span>, productId);</span><br><span class="line">    <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> updateCnt = update(<span class="string">"UPDATE tb_product SET stock=stock-1 WHERE id=#&#123;productId&#125;"</span>, productId);</span><br><span class="line">        <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用乐观锁"><a href="#使用乐观锁" class="headerlink" title="使用乐观锁"></a>使用乐观锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下单减库存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateStock</span><span class="params">(Long productId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> updateCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (updateCnt == <span class="number">0</span>) &#123;</span><br><span class="line">        ProductStock product = query(<span class="string">"SELECT * FROM tb_product WHERE product_id=#&#123;productId&#125;"</span>, productId);</span><br><span class="line">        <span class="keyword">if</span> (product.getNumber() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            updateCnt = update(<span class="string">"UPDATE tb_product SET stock=stock-1 WHERE product_id=#&#123;productId&#125; AND number=#&#123;number&#125;"</span>, productId, product.getNumber());</span><br><span class="line">            <span class="keyword">if</span>(updateCnt &gt; <span class="number">0</span>)&#123;    <span class="comment">//更新库存成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//卖完啦</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis为什么这么快</title>
    <url>/2019/02/18/ckybpqxed000dd2nhgmag5blg/</url>
    <content><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><ul>
<li><p>Redis是一个开源的内存中的数据结构存储系统，它可以用作：<strong>数据库、缓存和消息中间件</strong> </p>
</li>
<li><p>它支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。</p>
</li>
<li><p>Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p>
<a id="more"></a>
</li>
<li><p>Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</p>
</li>
<li><p>Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。</p>
</li>
<li><p>数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。</p>
</li>
</ul>
<h2 id="Redis有多快"><a href="#Redis有多快" class="headerlink" title="Redis有多快"></a>Redis有多快</h2><p>Redis采用的是基于内存的采用的是<strong>单进程单线程</strong>模型的 <strong>KV 数据库</strong>，<strong>由C语言编写</strong>，官方提供的数据是可以达到100000+的QPS（每秒内查询次数） </p>
<p>简单测试(2G单核)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PING_INLINE: 82236.84 requests per second</span><br><span class="line">PING_BULK: 89525.52 requests per second</span><br><span class="line">SET: 82987.55 requests per second</span><br><span class="line">GET: 67659.00 requests per second</span><br><span class="line">INCR: 71022.73 requests per second</span><br><span class="line">LPUSH: 73206.44 requests per second</span><br><span class="line">RPUSH: 69252.08 requests per second</span><br><span class="line">LPOP: 66800.27 requests per second</span><br><span class="line">RPOP: 70671.38 requests per second</span><br><span class="line">SADD: 68965.52 requests per second</span><br><span class="line">SPOP: 90497.73 requests per second</span><br><span class="line">LPUSH (needed to benchmark LRANGE): 85984.52 requests per second</span><br><span class="line">LRANGE_100 (first 100 elements): 35050.82 requests per second</span><br><span class="line">LRANGE_300 (first 300 elements): 13255.57 requests per second</span><br><span class="line">LRANGE_500 (first 450 elements): 8701.71 requests per second</span><br><span class="line">LRANGE_600 (first 600 elements): 6487.61 requests per second</span><br><span class="line">MSET (10 keys): 64226.07 requests per second</span><br></pre></td></tr></table></figure>
<h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><ol>
<li><p>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)； </p>
</li>
<li><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗 </p>
</li>
<li><p>使用多路I/O复用模型，非阻塞IO； </p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 <span class="literal">I</span>/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 <span class="literal">I</span>/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的 </p>
</li>
</ol>
<p>但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善 </p>
<h2 id="Redis为什么是单线程的"><a href="#Redis为什么是单线程的" class="headerlink" title="Redis为什么是单线程的"></a>Redis为什么是单线程的</h2><p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了 ，多线程会增加复杂度，使用锁机制来保证数据一致性</p>
<blockquote>
<p>这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行 </p>
</blockquote>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>数据库，缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>搞定redis</title>
    <url>/2018/09/27/ckybpqxed000ed2nhb043b8a4/</url>
    <content><![CDATA[<h4 id="为什么需要redis集群"><a href="#为什么需要redis集群" class="headerlink" title="为什么需要redis集群"></a>为什么需要redis集群</h4><h4 id="怎么搭建redis集群"><a href="#怎么搭建redis集群" class="headerlink" title="怎么搭建redis集群"></a>怎么搭建redis集群</h4><h4 id="redis官方搭建集群的方式redis-cluster"><a href="#redis官方搭建集群的方式redis-cluster" class="headerlink" title="redis官方搭建集群的方式redis-cluster"></a>redis官方搭建集群的方式<code>redis-cluster</code></h4>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库，redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动配置的魔法</title>
    <url>/2019/02/19/ckybpqxee000fd2nhg24387sk/</url>
    <content><![CDATA[<h3 id="从-SpringBootApplication注解说起"><a href="#从-SpringBootApplication注解说起" class="headerlink" title="从@SpringBootApplication注解说起"></a>从@SpringBootApplication注解说起</h3><p><code>SpringBoot</code>会根据类路径下的类自动配置，省去了编写繁琐的<code>xml</code>配置文件。原本基于<code>xml</code>配置<code>bean</code>的方式编程基于Java代码，并且可以条件化配置，根据不同的场景配置也随之不同。是不是很智能</p>
<a id="more"></a>
<p>为了清楚<code>SpringBoot</code>自动配置的原理，我们从最简单的<code>SpringBoot</code>的启动类说起，看一个简单的启动实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SpringBoot</code>应用的启动很简单，就是一个<code>main</code>方法，然后执行<code>SpringApplication</code>的run方法。先不关心run方法是怎么执行的。我们先看<code>SpringBoot</code>应用的核心注解<code>@SpringBootApplication</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">		@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看该注解的源代码可知，这是一个组合注解。</p>
<p>分别查看每个注解的含义</p>
<p><code>@SpringBootConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知该注解就是<code>@Configuration</code>注解，该注解什么这个一个配置类，在<code>SpringBoot</code>中很常见。</p>
<p><code>@CompontScan</code>注解指定哪些包扫描或者不扫描。</p>
<p>使<code>SpringBoot</code>应用拥有自动配置魔法的注解是<code>@EnableAutoConfiguraion</code>。该注解可以让SpringBoot根据类路径中的依赖为当前项目进行自动配置 ，所以SpringBoot可以自动配置主要是因为SpringBoot应用上的@EnableAutoConfiguraion注解来实现的，所以在启动类上加入该注解，就会开启自动配置。</p>
<p>那么，这个注解是如何实现自动化配置的呢。接下来我们要一探究竟。</p>
<h3 id="自动配置背后的注解"><a href="#自动配置背后的注解" class="headerlink" title="自动配置背后的注解"></a>自动配置背后的注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该注解也是一个组合注解，这里有一个<code>@Import(AutoConfigurationImportSelector.class)</code>，那么<code>@Import</code>注解的作用是什么呢，查看<code>@Import</code>的源码注释，写着<code>Indicates one or more {@link Configuration @Configuration} classes to import.Provides functionality equivalent to the {@code &lt;import/&gt;} element in Spring XML.</code>，注释表明这个注解指明了要导入的配置类，在功能上和<code>Spring XML配置</code>中的<code>&lt;import&gt;</code>相同</p>
<p>那这里<code>@Import</code>导入的一个<code>AutoConfigurationImportSelector</code>又什么作用呢？根据下面注释中的内容可以知道，<code>@Import</code>允许导入<code>ImportSelector,ImportBeanDefinitionRegistrar</code>的实现类，还有普通的类（在版本4.2后）</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Allows</span> <span class="selector-tag">for</span> <span class="selector-tag">importing</span> &#123;<span class="variable">@code</span> <span class="variable">@Configuration</span>&#125; <span class="selector-tag">classes</span>, &#123;<span class="variable">@link</span> ImportSelector&#125; <span class="selector-tag">and</span> &#123;<span class="variable">@link</span> ImportBeanDefinitionRegistrar&#125; <span class="selector-tag">implementations</span>, <span class="selector-tag">as</span> <span class="selector-tag">well</span> <span class="selector-tag">as</span> <span class="selector-tag">regular</span> <span class="selector-tag">component</span> <span class="selector-tag">classes</span> (as of <span class="number">4.2</span>; analogous to &#123;<span class="variable">@link</span> AnnotationConfigApplicationContext#register&#125;).</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到了这里，说一个与@Import注解相关的东西，Spring框架本身提供了几个以Enable打头的注解，根据名字可知这是开启某个功能，比如<code>@EnableScheduling</code>、<code>@EnableCaching</code>、<code>@EnableMBeanExport</code>等，<code>@EnableAutoConfiguration</code>的理念和这些注解其实是相同的的。 </p>
</blockquote>
<blockquote>
<p><code>@EnableScheduling</code>是通过<code>@Import</code>将Spring调度框架相关的bean定义都加载到IoC容器。<code>@EnableMBeanExport</code>是通过<code>@Import</code>将JMX相关的bean定义加载到IoC容器。</p>
<p><code>@EnableAutoConfiguration</code>也是借助<code>@Import</code>的帮助，将所有符合自动配置条件的bean定义加载到IoC容器。</p>
</blockquote>
<p>接下来关注EnableAutoConfigurationImportSelector 这个作用是什么。主要就是使用Spring 4 提供的的<code>SpringFactoriesLoader</code>工具类。通过<code>SpringFactoriesLoader.loadFactoryNames()</code>读取了ClassPath下面的<code>META-INF/spring.factories</code>文件 </p>
<p><code>EnableAutoConfigurationImportSelector</code>通过读取<code>spring.factories</code>中的key为<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>的值。如<code>spring-boot-autoconfigure-1.5.1.RELEASE.jar</code>中的<code>spring.factories</code>文件包含以下内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们新定义了一个<code>starter</code>的话，也要在该<code>starter</code>的<code>jar</code>包中提供 <code>META-INFO/spring.factories</code>文件，并且为其配置<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>对应的配置类 </p>
</blockquote>
<p>从<code>EnableAutoConfiguration</code>寻找一个配置类CacheAutoConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CacheManager<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnBean</span>(<span class="title">CacheAspectSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">value</span> </span>= CacheManager<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= <span class="string">"cacheResolver"</span>)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(CacheProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; CouchbaseAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">HazelcastAutoConfiguration</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">HibernateJpaAutoConfiguration</span>.<span class="title">class</span>, <span class="title">RedisAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(<span class="title">CacheConfigurationImportSelector</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CacheAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CacheManagerCustomizers <span class="title">cacheManagerCustomizers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ObjectProvider&lt;List&lt;CacheManagerCustomizer&lt;?&gt;&gt;&gt; customizers)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> CacheManagerCustomizers(customizers.getIfAvailable());</span><br><span class="line">	&#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个<code>@Configuration</code>配置类，包含<code>@Bean</code>的方法的返回值会注册为一个<code>bean</code></p>
<p>在这个类和方法上我们看到很多条件配置注解</p>
<p>条件配置主要的注解是<code>@Conditional</code>,这个注解指定一个实现了<code>Condition</code>的类，类中实现了<code>matchs</code>方法，如果方法返回<code>true</code>，被<code>@Conditional</code>修饰的类或者方法才会创建<code>bean</code>。为了方便<code>Spring4</code>中已经帮我们实现了一些常用的条件配置注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span></span><br><span class="line"><span class="meta">@ConditionalOnExpression</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass</span></span><br><span class="line"><span class="meta">@ConditionalOnNotWebApplication</span></span><br></pre></td></tr></table></figure>
<p>至此，我们已经分析了<code>SpringBoot</code>中自动化配置的基本原理，接下来我们会编写一个<code>spring-boot-starter</code></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <url>/2018/08/18/ckybpqxef000gd2nha4slft4q/</url>
    <content><![CDATA[<h4 id="TCP连接的建立（三次握手）"><a href="#TCP连接的建立（三次握手）" class="headerlink" title="TCP连接的建立（三次握手）"></a>TCP连接的建立（三次握手）</h4><p><img src="/2018/08/18/ckybpqxef000gd2nha4slft4q/TCP三次握手详细示意图.png" alt=""></p>
<a id="more"></a>
<ol>
<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 </li>
</ol>
<h5 id="为什么需要客户端最后一次发送"><a href="#为什么需要客户端最后一次发送" class="headerlink" title="为什么需要客户端最后一次发送"></a>为什么需要客户端最后一次发送</h5><blockquote>
<p>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</p>
</blockquote>
<p>三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：client端发出了一个连接请求报文，而是因为某些未知的原因在某个网络节点上发生延迟、滞留，导致延迟到连接释放以后的某个时间才到达server端。本来这是一个早已失效的报文段，但是server收到此失效的报文之后，会误认为是client再次发出的一个新的连接请求，于是server端就向client又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要server端发出确认报文就会认为新的连接已经建立了，但是client端此时并没有发出建立连接的请求，因此不会去向server端发送数据，server端没有收到数据就会一直等待，产生死锁现象，这样server端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，client端首先发出连接请求并进入等待状态，server接收连接请求后同意建立连接，并向client返回报文段表示已经建立连接server进入SYN_RECV状态，client接收到server发出的确认信息后自己再发出确认信息，然后就可以建立直接通信。所以说只有三次握手在逻辑上才是最合适的，可以保障可靠性</p>
<h4 id="TCP连接的释放（四次挥手）"><a href="#TCP连接的释放（四次挥手）" class="headerlink" title="TCP连接的释放（四次挥手）"></a>TCP连接的释放（四次挥手）</h4><p><img src="/2018/08/18/ckybpqxef000gd2nha4slft4q/TCP四次挥手详细示意图.png" alt=""></p>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ol>
<h5 id="为什么客户端最后发送ACK后还要等待2MSL"><a href="#为什么客户端最后发送ACK后还要等待2MSL" class="headerlink" title="为什么客户端最后发送ACK后还要等待2MSL"></a>为什么客户端最后发送ACK后还要等待2MSL</h5><blockquote>
<p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
</blockquote>
<p>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失,<code>服务器会在发送ACK+FIN报文后，应该接受到客户端的ACK应答，如果ACK报文在传输过程中丢失，那么服务端会重新发送一次ACK+FIN，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器</code></p>
<h5 id="为什么建立连接是三次握手，而释放连接需要四次挥手呢"><a href="#为什么建立连接是三次握手，而释放连接需要四次挥手呢" class="headerlink" title="为什么建立连接是三次握手，而释放连接需要四次挥手呢"></a>为什么建立连接是三次握手，而释放连接需要四次挥手呢</h5><ul>
<li>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 </li>
<li>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.use初探</title>
    <url>/2018/12/21/ckybpqxef000hd2nh6y7u7fyc/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>相信很多人在用Vue使用别人的组件时，会用到 <code>Vue.use()</code>。<br>例如：<code>Vue.use(VueRouter)、Vue.use(MintUI)</code>。<br>但是用 <code>axios</code>时，就不需要用 <code>Vue.use(axios)</code>，就能直接使用。</p>
<a id="more"></a>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>因为 <code>axios</code> 没有 <code>install</code>。<br>什么意思呢？接下来我们自定义一个需要 Vue.use() 的组件，也就是有 install 的组件，看完之后就明白了</p>
<p>建立一个简单的项目，项目结构如下：<br><img src="/2018/12/21/ckybpqxef000hd2nh6y7u7fyc/项目结构.png" alt=""></p>
<p>在<code>src/components/loading</code>目录下建立两个文件，分别是<code>index.js</code>和<code>loading.vue</code></p>
<p><code>loading.vue</code>的代码如下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Loading.........</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><br><code>index.js</code>的代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> LoadingComponent <span class="keyword">from</span> <span class="string">"./loading"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Loading = &#123;</span><br><span class="line">    <span class="comment">// install 是默认的方法。当 use 这个组件的时候，就会调用本身的 install 方法，同时传一个 Vue 这个类的参数。</span></span><br><span class="line">    <span class="comment">// install 方法的第一个参数就是Vue</span></span><br><span class="line">    install: <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.util.init()</span><br><span class="line">        Vue.component(<span class="string">'Loading'</span>, LoadingComponent)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component register to gobla context......'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 在这里面可以添加其它的逻辑</span></span><br><span class="line">    util: &#123;</span><br><span class="line">        init:<span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'component init.........'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Loading</span><br></pre></td></tr></table></figure></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>接下来在<code>main.js</code>中use该组件<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> Loading <span class="keyword">from</span> <span class="string">'./components/loading/index'</span>   <span class="comment">// index可以不用写，默认加载index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册组件  执行组件的install</span></span><br><span class="line">Vue.use(Loading)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>在Loading组件的install方法中我们已经使用<code>Vue.component</code>方法注册了组件<br>所以在App.vue中直接使用即可<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;vue loading&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Loading /</span>&gt; </span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">//import Loading from './components/loading/loading.vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'app'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'Welcome to Your Vue.js App'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 局部注册组件</span></span><br><span class="line"><span class="comment">//   components:&#123;</span></span><br><span class="line"><span class="comment">//       Loading</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><br>这样我们在Vue全局中注册了该组件，在vue的任何一个实例上可以直接使用</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Plugins</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue.use</tag>
      </tags>
  </entry>
  <entry>
    <title>maven-source-plugin</title>
    <url>/2021/07/24/ckybpqxeg000id2nh6e8ceku4/</url>
    <content><![CDATA[<h1 id="maven-source-plugin"><a href="#maven-source-plugin" class="headerlink" title="maven-source-plugin"></a>maven-source-plugin</h1><blockquote>
<p>源码在哪儿？</p>
</blockquote>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>我们在IDEA中查看Maven包的代码时，右上角会有一个下载源码，这样我们就可以从仓库中获取到jar包对应的源码。</p>
<p>要获取源码，首先要在上传构建(项目)到仓库的时候同时上传source(源码)文件。</p>
<p>下面是Maven官网对于该插件的描述:</p>
<blockquote>
<p>The Source Plugin creates a jar archive of the source files of the current project. The jar file is, by default, created in the project’s target directory.</p>
</blockquote>
<p>大致意思就是创建一个包含当前项目源码的jar压缩文件，默认情况下，这个jar压缩文件创建在target目录下</p>
<a id="more"></a>
<blockquote>
<p>提示：从插件的 3.0.0 版开始，所有可以通过命令行使用的属性都基于以下架构 maven.source.* 命名</p>
</blockquote>
<p>下面是该插件所包含的goal:</p>
<ul>
<li><a href="http://maven.apache.org/plugins/maven-source-plugin/aggregate-mojo.html" target="_blank" rel="noopener">source:aggregate</a> aggregrates sources for all modules in an aggregator project.</li>
<li><a href="http://maven.apache.org/plugins/maven-source-plugin/jar-mojo.html" target="_blank" rel="noopener">source:jar</a> is used to bundle the main sources of the project into a jar archive.</li>
<li><a href="http://maven.apache.org/plugins/maven-source-plugin/test-jar-mojo.html" target="_blank" rel="noopener">source:test-jar</a> on the other hand, is used to bundle the test sources of the project into a jar archive.</li>
<li><a href="http://maven.apache.org/plugins/maven-source-plugin/jar-no-fork-mojo.html" target="_blank" rel="noopener">source:jar-no-fork</a> is similar to <strong>jar</strong> but does not fork the build lifecycle.</li>
<li><a href="http://maven.apache.org/plugins/maven-source-plugin/test-jar-no-fork-mojo.html" target="_blank" rel="noopener">source:test-jar-no-fork</a> is similar to <strong>test-jar</strong> but does not fork the build lifecycle.</li>
</ul>
<p>maven中的<code>fork</code>是什么？</p>
<p>true 意味着它将创建（fork）一个新的<code>JVM</code>来运行编译器。这有点慢，但隔离更好。特别是可以指定一个不同于 Maven 启动的 JVM</p>
<h2 id="2-怎么使用"><a href="#2-怎么使用" class="headerlink" title="2. 怎么使用"></a>2. 怎么使用</h2><h3 id="2-1-创建maven项目-模块"><a href="#2-1-创建maven项目-模块" class="headerlink" title="2.1 创建maven项目/模块"></a>2.1 创建maven项目/模块</h3><p>第一步当然是搭建一个maven的项目或者模块，这里就不用过多演示了，大家都会</p>
<h3 id="2-2-pom中添加插件"><a href="#2-2-pom中添加插件" class="headerlink" title="2.2 pom中添加插件"></a>2.2 pom中添加插件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 绑定source插件到Maven的生命周期,并在生命周期后执行绑定的source的goal --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 绑定source插件到Maven的生命周期 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--在生命周期后执行绑定的source插件的goals --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面截取的一段定义就是配置maven-source-plugin插件，并绑定goal- <code>jar-no-fork</code>到default生命周期的compile phase,这样我们指定paase的执行就可以执行插件的goal</p>
<p>现在我们来试一下该插件，我们可以在terminal中切换到该项目下，然后执行<code>mvn compile</code>看效果:</p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210724183028418.png" alt="image-20210724183028418"></p>
<p>假如我们没有绑定到生命周期的某一个phase而想要执行这个插件怎么做呢，就可以直接使用<code>goal而不是phase</code>来构建。</p>
<p>例如，我们把上面的exxcutions节点下所有的内容注释掉，然后在命令行执行mvn source:jar-no-fork也可以得到source打包后的文件</p>
<h2 id="3-使用建议"><a href="#3-使用建议" class="headerlink" title="3. 使用建议"></a>3. 使用建议</h2><ol>
<li>如果在多项目的构建中，maven-source-plugin放在顶层的pom中是不会起作用的，需要放到具体的某一个项目中</li>
<li>使用了该插件，在deploy到远程仓库后也会带上该项目的source文件</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>maven-plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树，二叉平衡树</title>
    <url>/2018/08/20/ckybpqxeh000jd2nh4vv3cxhd/</url>
    <content><![CDATA[<p>Java集合<code>TreeMap</code>和<code>TreeSet</code>中底层使用了红黑树，<code>集合HashMap</code>在JDK1.8 使用了<code>数组+链表+红黑树</code>的数据结构</p>
<p>那么到底什么是红黑树呢，上数据结构课程的时候只是学到了二叉查找树(Binery Search Tree,BST)的概念，简单介绍过平衡树。</p>
<p>现在再来看一下什么是二叉查找树和平衡树</p>
<a id="more"></a>
<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉查找树又称二叉排序树</p>
<h2 id="二叉查找树的特点"><a href="#二叉查找树的特点" class="headerlink" title="二叉查找树的特点"></a>二叉查找树的特点</h2><p>排序二叉树是一种特殊结构的二叉树，可以非常方便地对树中所有节点进行排序和检索。</p>
<p>排序二叉树要么是一棵空二叉树，要么是具有下列性质的二叉树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>它的左、右子树也分别为排序二叉树</li>
</ul>
<p>二叉排序树的结构如下：</p>
<p><img src="/2018/08/20/ckybpqxeh000jd2nh4vv3cxhd/二叉排序树.png" alt=""></p>
<p>按照这种方式来进行查找，正是二分查找的思想，查找所需的最大次数等于二叉查找树的高度。插入节点的时候也是一层一层比较，然后找到合适的位置插入</p>
<h2 id="二叉查找树缺点"><a href="#二叉查找树缺点" class="headerlink" title="二叉查找树缺点"></a>二叉查找树缺点</h2><p>但是，二叉查找树也有自身的缺点</p>
<p>例如：假设初始的二叉查找树只有三个节点，根节点值为9，左孩子值为8，右孩子值为12</p>
<p>接下来我们依次插入如下五个节点：7,6,5,4,3。依照二叉查找树的特性，结果会变成什么样呢？</p>
<p><img src="/2018/08/20/ckybpqxeh000jd2nh4vv3cxhd/二叉排序树缺点.png" alt=""></p>
<p>如此一来，查找就变成了线性查找，查找的效率大大降低</p>
<p>那么如何解决新节点的插入导致二叉查找树不平衡呢，这就引入了平衡树的概念</p>
<h1 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h1><p>平衡二叉树：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。构造与调整方法 平衡二叉树的常用算法有红黑树、AVL、Treap等</p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是一种自平衡的二叉查找树，除了具有二叉查找树的特点外，还具有以下特性：</p>
<ul>
<li>节点是红色或者黑色</li>
<li>根节点是黑色</li>
<li>每个叶节点都是红色的空节点</li>
<li>每个红色节点的两个子节点都是黑色</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ul>
<p>下面就是一颗红黑树</p>
<p><img src="/2018/08/20/ckybpqxeh000jd2nh4vv3cxhd/红黑树.png" alt=""></p>
<p>由此我们可以得出结论：对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)</p>
<ul>
<li>红黑树通过上面这种限制来保证它大致是平衡的——因为红黑树的高度不会无限增高，这样保证红黑树在最坏情况下都是高效的，不会出现普通排序二叉树的情况。</li>
<li>由于红黑树只是一个特殊的排序二叉树，因此对红黑树上的只读操作与普通排序二叉树上的只读操作完全相同，只是红黑树保持了大致平衡，因此检索性能比排序二叉树要好很多。</li>
<li>但在红黑树上进行插入操作和删除操作会导致树不再符合红黑树的特征，因此插入操作和删除操作都需要进行一定的维护，以保证插入节点、删除节点后的树依然是红黑树</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>数据结构，树</tag>
      </tags>
  </entry>
  <entry>
    <title>从磁盘结构到数据库索引</title>
    <url>/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/</url>
    <content><![CDATA[<h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/Disk结构.jpg" alt=""></p>
<p>按照顺时针方向，一个盘片由很多<code>section</code>组成，编号<code>0-N</code>。从里向外分，又由多个<code>track</code>组成，编号<code>0-N</code>,<code>section</code>和<code>track</code>交叉的地方叫做<code>block</code>,所以一个<code>block</code>可以由<code>section</code>和<code>track</code>来定位。每一个<code>block</code>的大小是一样的。</p>
<a id="more"></a>
<p>操作系统读取数据都是按照<code>block</code>为单位进行。</p>
<p>在<code>block</code>内，数据的存储结构可以看成一个一维数组，大致结构是这样(假设一个<code>block</code>的<code>size</code>为<code>512byte</code>)</p>
<p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/Disk中一个block存储结构.jpg" alt=""></p>
<p><code>Disk</code>的读写头可以旋转和伸缩来定位一个<code>block</code></p>
<p>为了使磁盘中的数据可以被应用程序使用，必须先<code>copy</code>数据到随机读写存储器<code>RAM</code>中,而这正是耗时的操作。</p>
<h2 id="磁盘如何存储数据库数据"><a href="#磁盘如何存储数据库数据" class="headerlink" title="磁盘如何存储数据库数据"></a>磁盘如何存储数据库数据</h2><p>假设现在有一个<code>Employee</code>表，其中有一些字段，如下所示，所以一行数据的大小是<code>128byte</code></p>
<p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/employee数据结构.png" alt=""></p>
<p>假设总共有100行这样的数据</p>
<p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/employee在和磁盘的关系.png" alt=""></p>
<p>所以每一个<code>block</code>可以存储4行这样的数据，这<code>100行</code>数据需要<code>25个block</code>,假设现在按照这样的方式来查询一条记录，最多需要查找<code>25个block</code>.</p>
<p>那索引为什么可以减少查找的次数呢？</p>
<h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>我们建一个简单的索引，有两个字段，一个<code>eid</code>，表示<code>employee</code>的<code>id</code>，还有一个字段<code>pointer</code>，指向数据存储在<code>disk</code>上的位置。<code>empolyee</code>中的每一行，在<code>index</code>上都有一条记录 </p>
<p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/简单的索引.png" alt=""></p>
<p>当然我们也需要考虑如何存储这个索引表。如果索引存放在<code>disk</code>上，那么这个索引需要占据多少个<code>block</code>呢？<code>eid</code>大小为<code>10bytes</code>，<code>pointer</code>大小为<code>6bytes</code>，所以一行索引就有<code>16个bytes</code>大小。<code>100条</code>索引就需要占据<code>100 * 16 / 512</code>，也就是 <code>4个block</code> </p>
<p>在现在的情况下，我们查找<code>employee</code>表中的一条数据，最多就只需要<code>4</code>次索引表查找和一次<code>employee</code>表读取,相比没有索引的情况效率提升了很多</p>
<h2 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h2><p>如果现在把<code>employee</code>表中的数据行数增加到<code>1000行</code>，那么同理，数据表需要<code>250个block</code>,索引表需要<code>40个block</code>,现在查询一条记录就最多需要<code>41次block</code>的读取和拷贝(<code>IO</code>)</p>
<p>根据建立索引可以减少查找次数的理论，我们现在可以建立二级索引，也就是对上面的一级索引再建立索引，二级索引存储<strong>一级索引</strong><code>所在的block</code>,现在一级索引占用<code>40个bloc</code>k,所以二级索引表有<code>40</code>条记录，每一个索引记录大小为<code>16byte</code>,所以二级索引占用的<code>block</code>为<code>40*16/512</code>,也就是<code>2个block</code>。那么现在再来根据二级索引查找到一级索引所在的<code>block</code>,再根据一级索引直接定位到<code>employee</code>表中的某条数据所在的<code>block</code>，最多一共需要<code>2+1+1=4</code>次查找(<code>IO</code>),相比之前效率又提升了不少。</p>
<p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/二级索引.png" alt=""></p>
<p>随着数据表中数据记录的增加，可以建立三级，四级….索引来减少IO次数</p>
<h2 id="多路-n-way-搜索树"><a href="#多路-n-way-搜索树" class="headerlink" title="多路(n-way)搜索树"></a>多路(n-way)搜索树</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>每个节点只有一个值，一个节点最多两个子节点，左子节点比父节点小，右子节点比父节点大</p>
<p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/BST二叉搜索树.png" alt=""></p>
<p>一颗树代表了<code>某一级</code>索引，搜索树的高度(深度)代表了<code>最多IO</code>的次数，所以减少树的高度可以减少<code>IO</code>的次数</p>
<p>思路就是一个节点存储多个值，相应的子节点最大个数也可以有多个</p>
<h3 id="n-way搜索树"><a href="#n-way搜索树" class="headerlink" title="n-way搜索树"></a>n-way搜索树</h3><p>由二叉搜索树扩展，让每个节点最多可以存<code>n-1</code>个索引值，每个节点可以有<code>n</code>个子节点，就是<code>n-way</code>搜索树 </p>
<p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/多路搜索树.png" alt=""></p>
<p>上面就是一个<code>3路</code>搜索树</p>
<p>我们可以使用这样的数据结构来作为索引，但是<code>n-way</code>搜索树也存在一些问题</p>
<p>比如现在有三个数据：10，20，30，要用一个<code>10-way</code>搜索树来构建。很有可能，最终会构建出一个这样的树 </p>
<p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/多路搜索树缺陷.png" alt=""></p>
<p>这是一种最坏的情况，相当于退化成链表结构。</p>
<h2 id="B树：多路搜索树上增加限制"><a href="#B树：多路搜索树上增加限制" class="headerlink" title="B树：多路搜索树上增加限制"></a>B树：多路搜索树上增加限制</h2><p>B树，实际上可以看作是<code>n-way</code>搜索树 + 规则（如何构建这棵树的规则） </p>
<p>规则：</p>
<ul>
<li>每个节点至少有<code>[n/2]</code>个子节点</li>
<li>根节点可以最少有<code>2</code>个子节点</li>
<li>所有的叶子节点必须在一个层级</li>
<li>创建过程是由下往上的</li>
</ul>
<p>值：<code>10，20，40，50</code>。要构建一个<code>4-way</code>搜索树。<code>4-way</code>搜索树，意味着一个节点最多可以有<code>3</code>个值。 </p>
<p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/4-way搜索树.png" alt=""></p>
<p>继续插入操作，最后形成的结果是：</p>
<p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/4-way搜索树做索引图示.png" alt=""></p>
<p>每一个节点可以有多个值，每个值里面包含一个键和位置指针，键用来作为标识，数据值标识数据存放的位置</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>在<code>B+</code>树中，不是每个值旁边都有一个指向数据存储位置的指针，只有叶子节点才有。非叶子节点的值，在叶子节点上有他的副本 </p>
<p><img src="/2019/03/17/ckybpqxeh000kd2nh9gwf3hlx/B+树索引.png" alt=""></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库索引</tag>
      </tags>
  </entry>
  <entry>
    <title>递归理解-汉诺塔问题</title>
    <url>/2018/12/05/ckybpqxek000ld2nh17888u4s/</url>
    <content><![CDATA[<p>汉诺塔问题的求解可以巧妙利用递归思想</p>
<blockquote>
<p> 以下摘自知乎上我认为阐述得很清除回答：</p>
</blockquote>
<p>要用程序来解决这个问题，我们先定义一个移动函数：move（移动数，开始柱，中转柱，目标柱），<br>例如 move（2，A，B，C） 表示将2个盘子从A柱（开始柱）借助B柱（中转柱）移动到C柱（目标柱）。<br>关于开始柱，中转柱，目标柱这三个概念可以用移动过程中的某个状态来理解，</p>
<a id="more"></a>
<p>看下面一张图应该就能明白：<br>有三种状态的柱子，开始柱，中间柱，目标住，开始柱指的是开始状态时存放所有盘子的柱子，中转柱指的是中间状态时暂时存放n-1个（三层就是3-1个）盘子的柱子，<br>目标柱指的是盘子最终要移动到的柱子。这里需要注意，开始柱，中转柱，目标柱并不是一成不变的，而是会根据层次的不同而改变。（如果这里暂时不能理解的话，先读下去，再回头你就能明白了）。</p>
<p>接着我们分情况讨论一下盘子的移动：</p>
<h2 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h2><blockquote>
<p>当盘子只有1个（调用 move（1，A，B，C））当盘子只有一个的时候，</p>
</blockquote>
<ul>
<li>只要直接将盘子从开始柱移动到目标柱就可以了，并没有中间状态（即不用借助中转柱），在move方法中可以用一句话表示该移动动作  print（’A—&gt;C’）;</li>
</ul>
<h2 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h2><blockquote>
<p> 当盘子有2个（调用 move（2，A，B，C））这个情况分三个步骤进行：</p>
</blockquote>
<ul>
<li>step1.  把除了最大的盘子之外的盘子从A移到BA—&gt;B  (开始柱—&gt;中转柱)   【相当于调用  move（1，A，C，B）】</li>
<li>step2.  把最大的盘子从A移到CA—&gt;C  (开始柱—&gt;目标柱)   【相当于调用  move（1，A，B，C）】</li>
<li>step3.  把除了最大的盘子之外的盘子从B移到CB—&gt;C  (中转柱—&gt;目标柱)   【相当于调用  move（1，B，A，C）】我想对于以上两个情况大家应该是没有什么疑问的，是可以确定的。</li>
</ul>
<p>然后我们来看三层的情况</p>
<h2 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h2><blockquote>
<p> 当盘子有3个（调用 move（3，A，B，C））这个情况同样分三步进行：</p>
</blockquote>
<ul>
<li>step1. 把除了最大的盘子之外的盘子从A移到B（注意对于这个步骤来说此时A为开始柱，C为中转柱，B为目标柱，这样才能完成把最上面的2个盘子从A—&gt;B的任务）A—&gt;C  (开始柱—&gt;中转柱)   【相当于调用  move（1，A，B，C）】A—&gt;B  (开始柱—&gt;目标柱)   【相当于调用  move（1，A，C，B）】C—&gt;B  (中转柱—&gt;目标柱)   【相当于调用  move（1，C，A，B）】</li>
<li>step2.  把最大的盘子从A移到C（对于这个步骤来说此时A为开始柱，B为中转柱，C为目标柱，这样才能把最大的盘子从A—&gt;C）A—&gt;C  (开始柱—&gt;目标柱)   【相当于调用  move（1，A，B，C），即直接执行 print（’A—&gt;C’）】</li>
<li>step3.  把除了最大的盘子之外的盘子从B移到C（注意对于这个步骤来说此时B为开始柱，A为中转柱，C为目标柱，这样才能完成把处于step2中的中转柱的2个盘子从B—&gt;C的任务）B —&gt; A  (开始柱—&gt;中转柱)   【相当于调用  move（1，B，C，A）】B —&gt; C  (开始柱—&gt;目标柱)   【相当于调用  move（1，B，A，C）】A —&gt; C  (中转柱—&gt;目标柱)   【相当于调用  move（1，A，B，C）】</li>
</ul>
<p>情况三的描述可能一下子不是那么好理解，但是大家应该能发现情况三的step1和step3的形式和整整个情况二的形式很像吧？而且要注意到分析的层次不相同时，开始柱，中转柱，目标柱是不一样的。</p>
<p>对于step1来说中转柱是C，对于step3来说中转柱是A，对于整个情况三来说中转柱是B。</p>
<p>前面我们已经确定了情况二调用的函数是 move（2，A，B，C），其等价于A—&gt;B A—&gt;CB—&gt;C这三步，然情况三的step1是A—&gt;C  A—&gt;B  C—&gt;B  这三步，跟情况二的形式是一样的，根据前面情况二的转化，那这三步就可以转化成函数 move（2，A，C，B)情况三的step3同理，做转化就成了函数 move（2，B，A，C）<br>而情况三的step2可以直接用一句  print（’A—&gt;C’） 来代替  move（1，A，B，C）所以整个情况三就可以这样来表示：</p>
<ol>
<li>move（2，A，C，B)  //step1. </li>
<li>把除了最大的盘子之外的盘子从A移到Bprint（’A—&gt;C’）  //step2.  </li>
<li>把最大的盘子从A移到Cmove（2，B，A，C）  //step3.  </li>
<li>把除了最大的盘子之外的盘子从B移到C我们又知道情况三调用的函数是  move（3，A，B，C），</li>
</ol>
<p>所以以上三行代码其实就等价于函数  move（3，A，B，C）。</p>
<p>来到这里应该就可以发现一点端倪了，情况四（4层）调用的函数是 move（4，A，B，C），</p>
<ol>
<li>其用伪代码表示就是move（3，A，C，B)  //step1. </li>
<li>把除了最大的盘子之外的盘子从A移到Bprint（’A—&gt;C’）  //step2.  </li>
<li>把最大的盘子从A移到Cmove（3，B，A，C）  //step3.  </li>
<li>把除了最大的盘子之外的盘子从B移到C</li>
</ol>
<p>对此有怀疑的小伙伴可以自己写出情况四的每步具体步骤然后再做转化，限于篇幅这里不再列出。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>那其实可以总结出：对于n（n&gt;1）层汉诺塔，调用函数 move（n，A，B，C）来递归解决该问题，该函数执行的是</p>
<ol>
<li><p>move（n-1，A，C，B)  //step1. </p>
</li>
<li><p>把除了最大的盘子之外的盘子从A移到Bprint（’A—&gt;C’）  //step2.  </p>
</li>
<li><p>把最大的盘子从A移到Cmove（n-1，B，A，C）  //step3.  </p>
</li>
<li><p>把除了最大的盘子之外的盘子从B移到C</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>然后有了以上的理解之后，我们就可以尝试写出解决该问题的代码了，Python实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(n,A,B,C)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:             <span class="comment"># 1个盘子，直接打印出移动动作</span></span><br><span class="line">        print(A,<span class="string">'---&gt;'</span>,C)</span><br><span class="line">    <span class="keyword">else</span>:                <span class="comment"># n &gt; 1时，用抽象出的3步来移动</span></span><br><span class="line">        move（n<span class="number">-1</span>，A，C，B) <span class="comment">#step1.  把除了最大的盘子之外的盘子从A移到B</span></span><br><span class="line">        print(A,<span class="string">'---&gt;'</span>,C)  <span class="comment">#step2.  把最大的盘子从A移到C</span></span><br><span class="line">        move（n<span class="number">-1</span>，B，A，C）<span class="comment">#step3.  把除了最大的盘子之外的盘子从B移到C</span></span><br></pre></td></tr></table></figure>
<p>so，读到这里，我大胆猜测大部分人心里应该明白得七七八八了</p>
<p>这里给出Java代码的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoi</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> A,<span class="keyword">char</span> B,<span class="keyword">char</span> C)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果是移动过一个盘子</span></span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(A+<span class="string">"--&gt;"</span>+C);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 一个以上的盘子</span></span><br><span class="line">			<span class="keyword">int</span> r1 = move(n-<span class="number">1</span>,A,C,B);</span><br><span class="line">			System.out.println(A+<span class="string">"--&gt;"</span>+C);</span><br><span class="line">			<span class="keyword">int</span> r2 = move(n-<span class="number">1</span>,B,A,C);</span><br><span class="line">			<span class="keyword">return</span> r1+r2+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">6</span>;</span><br><span class="line">		<span class="keyword">int</span> result = Hanoi.move(count, <span class="string">'A'</span>, <span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line">		System.out.println(<span class="string">"total numbers of moves:"</span>+result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法，递归</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎问答图片爬取</title>
    <url>/2017/09/06/ckybpqxem000md2nhc7fh4vmf/</url>
    <content><![CDATA[<p>前段时间看到很多爬虫的案例，有很多爬招聘网站数据的，还有房产中介数据的，当然也有很多爬取知乎用户数据的，很多爬虫都是用Python语言，但是我不会用它，只能用Java写一个爬虫来抓取知乎问题下答案的图片链接</p>
<a id="more"></a>
<blockquote>
<p>先上一个下载的图片的截图</p>
</blockquote>
<p><img src="/2017/09/06/ckybpqxem000md2nhc7fh4vmf/ZhihuSpider.JPG" alt=""></p>
<p>看到网上这么多人写爬虫，心里也是羡慕，想着自己什么时候也可以写一个简单的爬虫来了解下爬虫的原理，这几天刚开学，就尝试来抓取知乎的图片，主要是因为知乎某些问答的妹子都很好看……</p>
<hr>
<h4 id="抓取的原理"><a href="#抓取的原理" class="headerlink" title="抓取的原理"></a>抓取的原理</h4><p>想办法获取图片的链接，然后添加到一个容器中，依次下载，很简单的</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>一开始我单纯的认为只要获取一个问答首页的源码，然后用正则表达式拿到图片链接，接下来就不是事儿了。但是这样做只能获取到第一页的数据</p>
<blockquote>
<p>下图为第一页的数据，每一个List-item就是一个回答，这儿一共才20条</p>
</blockquote>
<p><img src="/2017/09/06/ckybpqxem000md2nhc7fh4vmf/ListItem.JPG" alt=""></p>
<p>点击查看更多回答。<code>F12</code>中打开<code>network</code>选项卡，再选择<code>XHR</code>查看AJAX请求，发现有一个链接特别长，查看<code>request</code>和<code>response</code>,就发现了下图中的东西</p>
<p><img src="/2017/09/06/ckybpqxem000md2nhc7fh4vmf/XHR.JPG" alt=""></p>
<p>查看请求的详情，发现这个请求返回的是一个json数据</p>
<p><img src="/2017/09/06/ckybpqxem000md2nhc7fh4vmf/data.JPG" alt=""></p>
<p>这是一个实例链接：<code>https://www.zhihu.com/api/v4/questions/38906616/answers?include=data%5B*%5D.is_normal%2Cadmin_closed_comment%2Creward_info%2Cis_collapsed%2Cannotation_action%2Cannotation_detail%2Ccollapse_reason%2Cis_sticky%2Ccollapsed_by%2Csuggest_edit%2Ccomment_count%2Ccan_comment%2Ccontent%2Ceditable_content%2Cvoteup_count%2Creshipment_settings%2Ccomment_permission%2Ccreated_time%2Cupdated_time%2Creview_info%2Cquestion%2Cexcerpt%2Crelationship.is_authorized%2Cis_author%2Cvoting%2Cis_thanked%2Cis_nothelp%2Cupvoted_followees%3Bdata%5B*%5D.mark_infos%5B*%5D.url%3Bdata%5B*%5D.author.follower_count%2Cbadge%5B%3F(type%3Dbest_answerer)%5D.topics&amp;offset=3&amp;limit=20&amp;sort_by=default</code></p>
<p>链接参数中的offset表示与第一个回答的偏移量，limit表示返回回答数据的条数</p>
<p>我以为这样就可以了，用在线get工具测试了一下，看是不是相同的结果</p>
<p><img src="/2017/09/06/ckybpqxem000md2nhc7fh4vmf/responsewithoutauth.JPG" alt=""></p>
<p>结果响应了这样的json数据，根据那个英语，猜测是没有授权，于是去浏览器开发人员工具下寻找有没有什么特殊<code>request</code>的<code>Header</code>没有添加，于是发现了一个<code>authorization</code>的字段，故添加好header参数后再次尝试，结果呢？这次就对了</p>
<p><img src="/2017/09/06/ckybpqxem000md2nhc7fh4vmf/getwithauth.JPG" alt=""></p>
<p><img src="/2017/09/06/ckybpqxem000md2nhc7fh4vmf/responsewithauth.JPG" alt=""></p>
<p>如果问这个<code>authorization</code>字段的值怎么来的，其实我也不知道，我是复制的浏览器的数据</p>
<p>现在拿到了回答的json数据</p>
<p><img src="/2017/09/06/ckybpqxem000md2nhc7fh4vmf/data_json.JPG" alt=""></p>
<p>经过分析，每一个回答的json中有一个content属性，这个属性包含了回答的内容，其中就含有图片的链接。到此，感觉寄几终于找到了光明</p>
<p><img src="/2017/09/06/ckybpqxem000md2nhc7fh4vmf/content.JPG" alt=""></p>
<p>通过这个属性的值，就可以拿到图片的链接。</p>
<p>返回的这个json数据中还包含回答的总数等内容，更多有用的就自己去挖掘了哟</p>
<h4 id="使用的jar包："><a href="#使用的jar包：" class="headerlink" title="使用的jar包："></a>使用的jar包：</h4><ul>
<li><p>httpclient</p>
</li>
<li><p>json-lib:解析json数据</p>
</li>
</ul>
<blockquote>
<p>使用这些jar包还需要其它依赖包</p>
</blockquote>
<h4 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h4><ol>
<li>这个小项目中没有登录，所以有的需要登录账号的问题就不能获取到图片链接，会跳转到登录的页面</li>
<li>图片较多的时候下载时间会比较长，没有使用多线程技术</li>
</ol>
<p>最后附上项目的<code>github</code>地址<a href="https://github.com/watertreestar/ZhihuSpider" target="_blank" rel="noopener">Java抓取知乎图片</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>爬虫，Java</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域解决方案</title>
    <url>/2018/10/25/ckybpqxem000nd2nh9wsrgerb/</url>
    <content><![CDATA[<h1 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h1><p><code>js跨域</code>是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p>
<p>由于浏览器的同源策略</p>
<p>浏览器的同源策略会导致跨域，这里同源策略又分为以下两种</p>
<ol>
<li>DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。</li>
<li>XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求</li>
</ol>
<a id="more"></a>
<h1 id="为什么要有跨域限制"><a href="#为什么要有跨域限制" class="headerlink" title="为什么要有跨域限制"></a>为什么要有跨域限制</h1><p>了解完跨域之后，想必大家都会有这么一个思考，为什么要有跨域的限制，浏览器这么做是出于何种原因呢。其实仔细想一想就会明白，跨域限制主要是为了安全考虑。</p>
<p>AJAX同源策略主要用来防止CSRF攻击。如果没有AJAX同源策略，相当危险，我们发起的每一次HTTP请求都会带上请求地址对应的cookie，那么可以做如下攻击：</p>
<ol>
<li>用户登录了自己的银行页面 <code>http://mybank.com</code>，<code>http://mybank.com</code>向用户的cookie中添加用户标识。</li>
<li>用户浏览了恶意页面 <code>http://evil.com</code>。执行了页面中的恶意AJAX请求代码。</li>
<li><code>http://evil.com</code>向<code>http://mybank.com</code>发起AJAX HTTP请求，请求会默认把<code>http://mybank.com</code>对应cookie也同时发送过去。</li>
<li>银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。</li>
<li>而且由于Ajax在后台执行，用户无法感知这一过程。</li>
</ol>
<p>DOM同源策略也一样，如果iframe之间可以跨域访问，可以这样攻击：</p>
<ol>
<li>做一个假网站，里面用iframe嵌套一个银行网站 <code>http://mybank.com</code>。</li>
<li>把iframe宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。</li>
<li>这时如果用户输入账号密码，我们的主网站可以跨域访问到<code>http://mybank.com</code>的dom节点，就可以拿到用户的输入了，那么就完成了一次攻击。</li>
</ol>
<p>所以说有了跨域跨域限制之后，我们才能更安全的上网了。</p>
<h1 id="实现跨域请求的常用三种方式"><a href="#实现跨域请求的常用三种方式" class="headerlink" title="实现跨域请求的常用三种方式"></a>实现跨域请求的常用三种方式</h1><ul>
<li>JSONP</li>
<li>Nginx作反向代理</li>
<li>CORS策略</li>
</ul>
<h2 id="1、JSONP（JSON-with-padding）"><a href="#1、JSONP（JSON-with-padding）" class="headerlink" title="1、JSONP（JSON with padding）"></a>1、JSONP（JSON with padding）</h2><p><strong>原理</strong> ：</p>
<p>​      我们知道，在页面上有三种资源是可以与页面本身不同源的。它们是：js脚本，css样式文件，图片，像淘宝等大型网站，肯定会将这些静态资源放入cdn中，然后在页面上连</p>
<p>接，如下所示，所以它们是可以链接访问到不同源的资源的。</p>
<p><code>1）&lt;script type=&quot;text/javascript&quot; src=&quot;某某cdn地址&quot; &gt;&lt;/script&gt;</code></p>
<p><code>2）&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;某个cdn地址&quot; /&gt;</code></p>
<p><code>3）&lt;img src=&quot;某个cdn地址&quot; alt=&quot;&quot;/&gt;</code></p>
<p>　　而jsonp就是利用了script标签的src属性是没有跨域的限制的，从而达到跨域访问的目的。因此它的最基本原理就是：动态添加一个<code>&lt;script&gt;</code>标签来实现。</p>
<p><strong>实现方法：</strong></p>
<p>​    这里是使用ajax来请求的，看起来和ajax没啥区别，其实还是有区别的。</p>
<p>​    ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<script>标签来调用服务器提供的js脚本。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;  </span><br><span class="line">        url:<span class="string">"http://crossdomain.com/services.php"</span>,  </span><br><span class="line">        dataType:<span class="string">'jsonp'</span>,  </span><br><span class="line">        data:<span class="string">''</span>,  </span><br><span class="line">        jsonp:<span class="string">'callback'</span>,  </span><br><span class="line">        success:<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;  </span><br><span class="line">            <span class="comment">// some code</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代中，callback是必须的，callback是什么值要跟后台拿。获取到的jsonp数据格式如下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">flightHandler(&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="string">"CA1998"</span>,</span><br><span class="line">    <span class="string">"price"</span>: <span class="number">1780</span>,</span><br><span class="line">    <span class="string">"tickets"</span>: <span class="number">5</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>jsonp的全称为json with padding，上面的数据中，flightHandler就是那个padding.</p>
<p> <strong>JSONP的不足之处：</strong></p>
<p>　　1. 只能使用get方法，不能使用post方法：</p>
<p>　　我们知道 script，link, img 等等标签引入外部资源，都是 get 请求的，那么就决定了 jsonp 一定是 get 的。但有时候我们使用的 post 请求也成功，为啥呢？这是因为当我们指定dataType:’jsonp’,不论你指定：type:”post” 或者type:”get”，其实质上进行的都是 get 请求！</p>
<p>　　2. 没有关于 JSONP 调用的错误处理。如果动态脚本插入有效，就执行调用；如果无效，就静默失败。失败是没有任何提示的。例如，不能从服务器捕捉到 404 错误，也不能取消或重新开始请求。不过，等待一段时间还没有响应的话，就不用理它了。</p>
<h2 id="2、Nginx"><a href="#2、Nginx" class="headerlink" title="2、Nginx"></a>2、Nginx</h2><p>nginx作为反向代理服务器，就是把http请求转发到另一个或者一些服务器上。通过把本地一个url前缀映射到要跨域访问的web服务器上，就可以实现跨域访问。对于浏览器来说，访问的就是同源服务器上的一个url。而nginx通过检测url前缀，把http请求转发到后面真实的物理服务器。并通过rewrite命令把前缀再去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求是来自代理服务器的</p>
<h2 id="3、CORS策略"><a href="#3、CORS策略" class="headerlink" title="3、CORS策略"></a>3、CORS策略</h2><p><strong>原理：</strong></p>
<p>​     CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能同源使用的限制。它为<strong>Web服务器定义了一种方式</strong>，允许网页从不同的域访问其资源.</p>
<p>　　CORS系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，但比起简单地允许所有这些的要求来说更加安全。</p>
<p><strong>实现方法：</strong></p>
<p>　　CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>　　整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>前端方面</p>
<p>以前我们使用Ajax，代码类似于如下的方式：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>(); </span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"/hfahe"</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.send(); </span><br><span class="line"><span class="comment">// 这里的“/hfahe”是本域的相对路径。</span></span><br></pre></td></tr></table></figure>
<p>如果我们要使用CORS，相关Ajax代码可能如下所示：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>(); </span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"http://blog.csdn.net/hfahe"</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.send(); </span><br><span class="line"><span class="comment">// 请注意，代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。</span></span><br></pre></td></tr></table></figure>
<p>服务器方面<br>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>
<p><strong>CORS策略的优缺点：</strong></p>
<p>　　<strong>优点：</strong></p>
<p>　　　　1、CORS支持所有类型的HTTP请求。</p>
<p>　　　　2、 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</p>
<p>　　<strong>缺点：</strong> 兼容性方面相对差一点，ie10或以上才支持</p>
</script></p>]]></content>
      <categories>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>跨终端Web</title>
    <url>/2018/09/07/ckybpqxen000od2nh07g25sh5/</url>
    <content><![CDATA[<h3 id="一、跨终端web"><a href="#一、跨终端web" class="headerlink" title="一、跨终端web"></a>一、跨终端web</h3><p>一提到跨终端，第一反应往往就是响应式布局。这至少说明两点：首先，响应式本身与跨终端之间有着某种本质的联系；其次，人们误以为跨终端和响应式是同一件事。“跨终端 Web”是最终希望达到的目的，而达到这个目的的手段有很多，响应式仅仅是其中的一种方式而已。这些方式至少包括：</p>
<ul>
<li>响应式</li>
<li>多站点</li>
<li>多模板</li>
<li>多平台</li>
</ul>
<a id="more"></a>
<h4 id="1、响应式-单域"><a href="#1、响应式-单域" class="headerlink" title="1、响应式(单域)"></a>1、响应式(单域)</h4><p><strong>缺点：</strong></p>
<ul>
<li><strong>DOM冗余，javascript冗余</strong>：对于DOM结构异常庞大复杂的页面而言，响应式不能解决移动端DOM冗余的问题，JavaScript 脚本冗余也是一个问题；</li>
<li><strong>耦合度高</strong>：从工程实践来看，单个复杂响应式页面的维护成本并不比单独维护多个版本的页面成本低，并且由于响应式存在的内在耦合性，这个维护成本在复杂页面频繁更新时反而更高。</li>
<li><strong>超出css可控制范围</strong>：响应式本质上是依靠 CSS 处理展现层面的差异，大部分项目的移动端和 PC 端存在着不仅仅是展示上的差异，在交互形式上的巨大差异也会导致 DOM 结构上的差异，这种差异已经远远超出 CSS 所能控制的范围。</li>
</ul>
<h4 id="2、多站点-单域"><a href="#2、多站点-单域" class="headerlink" title="2、多站点(单域)"></a>2、多站点(单域)</h4><p><strong>缺点：</strong></p>
<p>通常一个网站要适配几个版本，针对手机、IPAD、小屏笔记本、大屏台式机，仅仅首页就要适配多个站点，整站下来维护成本太高。</p>
<h4 id="3、多模板-多域"><a href="#3、多模板-多域" class="headerlink" title="3、多模板(多域)"></a>3、多模板(多域)</h4><blockquote>
<p>多模板是响应式和多站点相结合的一种方案。</p>
</blockquote>
<p>多模板的优点在于一个页面只有一个 URL，无须服务器端复杂的 URL 映射规则和终端检测等手段进行跳转。虽然解决了响应式中 DOM 冗余的问题，但是由于单个页面存在多套模板，还需要在模板动态加载和首次服务器渲染等环节进行优化。</p>
<h4 id="4、多平台"><a href="#4、多平台" class="headerlink" title="4、多平台"></a>4、多平台</h4><p>Native App 的确也是实现跨终端 Web 的一种途径</p>
<p><strong>优点：</strong></p>
<ul>
<li>更好的性能、</li>
<li>更丰富的系统级功能的调用、</li>
<li>标准的发布渠道（通常是应用商店）</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>发布成本高</li>
<li>开发成本高</li>
<li>潜在的风险：如：ios严重依赖app store</li>
</ul>
<h3 id="二、Mobile-Web"><a href="#二、Mobile-Web" class="headerlink" title="二、Mobile Web"></a>二、Mobile Web</h3><p>html5有几大特性，虽然表面看上去只是一个版本的html，但其实我们通常意义上所说的html ~= html5 + css3 + javascript</p>
<h4 id="1、html5特点"><a href="#1、html5特点" class="headerlink" title="1、html5特点"></a>1、html5特点</h4><ul>
<li>语意化：新增了一系列的语意化标签，更利于网页的seo优化等等</li>
<li>离线存储：包括local storage等</li>
<li>设备访问：如定位信息、移动设备传感器等</li>
<li>多媒体：增加video、audio标签，提供原生的视频、音频访问</li>
<li>图形接口：增加canvas 标签</li>
<li>性能&amp;优化：</li>
<li>css3：</li>
</ul>
<h4 id="2、针对移动web的页面模板"><a href="#2、针对移动web的页面模板" class="headerlink" title="2、针对移动web的页面模板"></a>2、针对移动web的页面模板</h4><p>针对移动web页面，html5增加了一系列的 meta 标签，在上一篇文章中做过详细介绍，这里就不在赘述了，<a href="http://iqianduan.net/blog/mobile_web_html5_head" target="_blank" rel="noopener">传送门：移动前端的html5头标签head</a></p>
<h4 id="3、触屏事件"><a href="#3、触屏事件" class="headerlink" title="3、触屏事件"></a>3、触屏事件</h4><p>touch 以及 基于touch 的各种事件，drag（拖拽）、hold（长按）、pinch（捏）、rotate（旋转）、shake（重力感应等）</p>
<table>
<thead>
<tr>
<th>事件类别</th>
<th>事件描述</th>
<th>简称</th>
<th>别称</th>
</tr>
</thead>
<tbody>
<tr>
<td>tap</td>
<td>移动平台默认浏览器的click事件有300ms+的延时,通常使用touch事件模拟, 为区别点击称为拍击:. tap拍击 . doubletap 双击. hold 长按. tapn n(2,3..)指拍击</td>
<td>拍击</td>
<td>. android: touch. hold称呼较多: . android/ios: long press.wp: tap and hold. 也有称为press</td>
</tr>
<tr>
<td>swipe</td>
<td>按方向细分为:. swipe 单指滑动. swipeleft 单指向左滑动. swiperight 单指向右滑动. swipeup 单指向上滑动. swipedown 单指向下滑动. swipen n(2,3..)指滑动</td>
<td>滑动</td>
<td>wp: flick</td>
</tr>
<tr>
<td>drag</td>
<td>. drag 拖拽. dragstart 拖拽开始. dragend 拖拽结束. dragup 向上拖拽. dragdown 向下拖拽. dragleft 向左拖拽. dragright 向右拖拽</td>
<td>拖拽</td>
<td>ios/wp: pan</td>
</tr>
<tr>
<td>pinch</td>
<td>常用于放大(zoom in)缩小(zoom out)视图:. pinchin 双指捏合. pinchout 双指展开. squeeze 五指捏合. splay 五指展开</td>
<td>捏</td>
<td>. android: pinch open/close. pinchout也有称为spread</td>
</tr>
<tr>
<td>rotate</td>
<td>常用于旋转视图 . rotatecw 顺时针旋转. rotateccw 逆时针旋转</td>
<td>旋转</td>
<td></td>
</tr>
<tr>
<td>shake</td>
<td>常用于游戏中控制方向, 细分为:. shake 移动设备. shakeup 向上移动设备. shakedown 向下移动设备. shakeleft 向左移动设备. shakeright 向右移动设备. shakeforward 向前移动设备. shakeback 向后移动设备. shakeleftright 左右移动设备. shakeforwardback 前后移动设备. shakeupdown 上下移动设备</td>
<td>重力感应</td>
</tr>
</tbody>
</table>
<h4 id="4、调试"><a href="#4、调试" class="headerlink" title="4、调试"></a>4、调试</h4><p>1、远程调试</p>
<ul>
<li>Mobile Emulation：chrome 上面启动开发者工具，即可开启移动仿真状态</li>
<li>ios 远程调试 手机上 safari 浏览器开启开发者模式（设置–safari–高级–打开web检查器），电脑上面打开 safari 浏览器的开发模式，连接上手机，找到你手机上面打开的页面即可进行调试了。</li>
<li>Android 远程调试 安装Addroid Chrome 31+，使用USB 连接上手机，开启android的 USB debugger，安装ADB 扩展，安装后手动启动，PC chrome 使用 about: inspect 开启远程调试的控制台，单击 inspect 开始调试</li>
<li>weinre</li>
<li>HTTP 代理服务器</li>
</ul>
<p>2、设备调试</p>
<ul>
<li>设备模拟器</li>
<li>远程设备</li>
</ul>
<h3 id="三、基准"><a href="#三、基准" class="headerlink" title="三、基准"></a>三、基准</h3><h3 id="四、检测"><a href="#四、检测" class="headerlink" title="四、检测"></a>四、检测</h3><h4 id="1、终端"><a href="#1、终端" class="headerlink" title="1、终端"></a>1、终端</h4><p><strong>分类</strong>：</p>
<ul>
<li>按设备类型划分：目前普遍说的终端为三大类：PC电脑、平板、手机，当然TV 电视也即将成为第四大类</li>
<li>按操作系统划分：<ul>
<li>apple：OS X（桌面系统）、iOS（iPhone和Pad）</li>
<li>Google：Android（Phone和Pad）</li>
<li>Microsoft：覆盖手机、平板、个人电脑的windows系列</li>
</ul>
</li>
</ul>
<p><strong>终端检测</strong>：</p>
<ul>
<li>需要检测的场景：显示或隐藏特定内容////加载特定的静态资源样式、脚本////静态扫描修改文件源////返回指定图片质量、大小的图片</li>
<li>检测的原理：用户代理（User Agent—UA）最为常用</li>
<li>检测的实现：</li>
</ul>
<p><strong>遗留问题</strong></p>
<ul>
<li>硬件信息：UA 不准（浏览器厂商把UA伪装）</li>
<li>更精准的终端检测：引入机器学习，采集一定数量的样本学习后用于终端检测</li>
</ul>
<h3 id="五、接口"><a href="#五、接口" class="headerlink" title="五、接口"></a>五、接口</h3><h4 id="1、跨终端流程复用"><a href="#1、跨终端流程复用" class="headerlink" title="1、跨终端流程复用"></a>1、跨终端流程复用</h4><ul>
<li>如：购物网站前台页面展示有5种形式（PC、Phone Web、Pad Web、Phone App、Pad App），但后台的逻辑基本一致，则使用一套接口，增加流程的复用性。</li>
<li>如：移动优先，优先考虑移动端页面的展示，再开发PC的时候可适当扩展API</li>
</ul>
<h4 id="2、IF-interFace"><a href="#2、IF-interFace" class="headerlink" title="2、IF(interFace)"></a>2、IF(interFace)</h4><p>IF 主要包括以下几个部分：</p>
<ul>
<li>接口描述：请求、响应数据格式</li>
<li>接口文档：由接口描述生成接口文档</li>
<li>接口Mock：由接口描述生成接口 Mock 数据</li>
<li>接口校验：提供校验服务（HTTP）和校验工具包，支持多重格式的接口校验</li>
</ul>
<p><strong>缘由：来自于一次重构</strong></p>
<h3 id="六、定位"><a href="#六、定位" class="headerlink" title="六、定位"></a>六、定位</h3><h4 id="1、定位："><a href="#1、定位：" class="headerlink" title="1、定位："></a>1、定位：</h4><ul>
<li>hash：不利于SEO</li>
<li>history API：可结合ajax通过pjax的方式实现修改路由同时不刷新页面，只刷新部分内容<ul>
<li>history.pushState</li>
<li>history.replaceState</li>
<li>window.onpopstate：页面前进后退的时候触发</li>
</ul>
</li>
<li>视图定位：</li>
</ul>
<h4 id="2、数据："><a href="#2、数据：" class="headerlink" title="2、数据："></a>2、数据：</h4>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP缓存小结</title>
    <url>/2019/03/15/ckybpqxgj000rd2nhfdpb7711/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>提到页面优化，浏览器缓存必定是一个绕不过的话题，判断一个网站的性能最直观的就是看网页打开的速度，而提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。因此理解浏览器的缓存机制，就显得尤为重要。</p>
<p>这里我们简单介绍下浏览器的缓存</p>
<p>浏览器中的<code>HTTP</code>请求是一种应答模式，<code>HTTP</code>发起请求，服务器响应该请求，那么浏览器如何确定一个资源是否缓存，当请求一个资源的时候，应该去浏览器的缓存取，还是发送请求来获取该资源呢</p>
<p>缓存的关键：</p>
<ul>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 </li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中                                                                                                                                                                                                                         </li>
</ul>
<p>我们根据是否向浏览器发起请求分为强制缓存和协商缓存</p>
<a id="more"></a>
<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>不会向服务器发送请求，直接从缓存中读取资源，在<code>chrome</code>控制台的<code>network</code>选项中可以看到该请求返回200的状态码，并且<code>size</code>显示<code>from disk cache</code>或<code>from memory cache</code></p>
<p> 状态码为灰色的请求则代表使用了强制缓存，请求对应的<code>Size</code>值则代表该缓存存放的位置，分别为<code>from memory cache</code>和 <code>from disk cache</code></p>
<p><code>from memory cache</code>代表使用内存中的缓存，<code>from disk cache</code>则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为<code>memory – disk</code>。在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取<code>(from memory cache)</code>;而<code>css</code>文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存<code>(from disk cache)</code>。</p>
<h3 id="HTTP1-0的缓存"><a href="#HTTP1-0的缓存" class="headerlink" title="HTTP1.0的缓存"></a>HTTP1.0的缓存</h3><p>在 <code>HTTP1.0</code>时代，给客户端设定缓存方式可通过两个字段——<code>Pragma</code>和<code>Expires</code>来规范。虽然这两个字段早可抛弃，但为了做http协议的向下兼容，你还是可以看到很多网站依旧会带上这两个字段。</p>
<h3 id="pragma"><a href="#pragma" class="headerlink" title="pragma"></a>pragma</h3><p>当该字段值为<code>no-cache</code>的时候（事实上现在RFC中也仅标明该可选值），会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。 </p>
<h3 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h3><p>有了<code>Pragma</code>来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对<code>HTTP1.0</code>而言，<code>Expires</code>就是做这件事的首部字段。<code>Expires</code>的值对应一个<code>GMT（格林尼治时间）</code>，比如<code>Mon, 22 Jul 2002 11:12:01 GMT</code>来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。 </p>
<blockquote>
<p>expires设置的时间是服务器的时间，设置的是资源”失效”的时刻，如果时间客户端的时间和服务器的时间不一致，那这个缓存就没有意义了</p>
</blockquote>
<h2 id="HTTP1-1新增的cache-control"><a href="#HTTP1-1新增的cache-control" class="headerlink" title="HTTP1.1新增的cache-control"></a>HTTP1.1新增的cache-control</h2><p>针对上述的“    <code>Expires</code>时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了     <code>Cache-Control</code>来定义缓存过期时间。注意：若报文中同时出现了<code>Expires</code> 和 <code>Cache-Control</code>，则以 <code>Cache-Control</code>为准 ,使用格式：</p>
<p><code>&quot;cache-control&quot;:cache-directive</code></p>
<p>作为响应首部时,    <code>cache-directive</code> 的可选值有 ：</p>
<ul>
<li><code>public</code>：所有内容都将被缓存(客户端和代理服务器都可缓存)。具体来说响应可被任何中间节点缓存，如 Browser – proxy1 – proxy2 – Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。</li>
<li><code>private</code>：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser – proxy1 – proxy2 – Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。</li>
<li><code>no-cache</code>：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</li>
<li><code>no-store</code>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
<li><p><code>max-age</code>：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效</p>
</li>
<li><p><code>s-maxage(单位为s)</code>：同max-age，只用于共享缓存(比如CDN缓存)。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。</p>
</li>
</ul>
<blockquote>
<p>优先级从高到低分别是 <strong>Pragma -&gt; Cache-Control -&gt; Expires</strong> </p>
</blockquote>
<blockquote>
<p>Cache-Control使用的是时间间隔，Expires使用的是失效时刻</p>
</blockquote>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢?此时我们需要用到协商缓存策略 </p>
<p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程 </p>
<h2 id="缓存校验字段"><a href="#缓存校验字段" class="headerlink" title="缓存校验字段"></a>缓存校验字段</h2><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>服务器将资源传递给客户端时，会将资源最后更改的时间以<code>Last-Modified: GMT”</code>的形式加在实体首部上一起返回给客户端 ,值代表资源上次修改的时间</p>
<p>次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回<code>304</code>状态码，<strong>内容为空</strong>，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回<code>200</code>状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个<code>304</code>响应比一个静态资源通常小得多，这样就节省了网络带宽 </p>
<p><img src="http://imweb-io-1251594266.file.myqcloud.com/FozLFZKB5y67NUSXLhioLseHJYbE" alt=""></p>
<p> 传递<code>Last-Modified</code>的请求报文首部字段一共有两个：</p>
<ul>
<li>If-Modified-Since: Last-Modified-value</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例为 If-Modified-Since: Thu, <span class="number">31</span> Mar <span class="number">2016</span> <span class="number">07</span>:<span class="number">07</span>:<span class="number">52</span> GMT</span><br><span class="line">该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送<span class="number">304</span> 和响应报头即可。</span><br><span class="line">当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。</span><br></pre></td></tr></table></figure>
<ul>
<li>If-Unmodified-Since: Last-Modified-value</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">该值告诉服务器，若<span class="keyword">Last</span>-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回<span class="number">412</span>`(Precondition Failed) 状态码给客户端。 <span class="keyword">Last</span>-Modified 存在一定问题，如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为<span class="keyword">Last</span>-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）</span><br></pre></td></tr></table></figure>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>为了解决<code>Last-Modified</code>的不准确（文件修改时间改了，但文件内容却没有变 ）问题，<code>HTTP1.1</code>还增加了<code>ETag</code>实体首部字段, 服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志），在把资源<strong>响应</strong>给客户端的时候，会在实体首部加上<code>“ETag: 唯一标识符”</code>一起返回给客户端。 </p>
<p>客户端会保留该 <code>ETag</code> 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的<code>ETag</code>跟自己服务器上该资源的<code>ETag</code>是否一致，就能很好地判断资源相对客户端而言是否被修改过了。 如果服务器发现<code>ETag</code>匹配不上，那么直接以常规GET <code>200</code>回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果<code>ETag</code>是一致的，则直接返回<code>304</code>知会客户端直接使用本地缓存即可 </p>
<p>传递<code>ETag</code>的请求报文也有两个:</p>
<ul>
<li>If-None-Match: ETag-value</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">示例为 If-None-<span class="built_in">Match</span>: <span class="string">"5d8c72a5edda8d6a:3239"</span> 告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送<span class="number">304</span> 和响应报头即可。 当前各浏览器均是使用的该请求首部来向服务器传递保存的 ETag 值</span><br></pre></td></tr></table></figure>
<ul>
<li>If-None-Match:ETag-value</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回<span class="number">412</span>(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中;生效则返回304，继续使用缓存。</p>
<h3 id="用户刷新-访问行为"><a href="#用户刷新-访问行为" class="headerlink" title="用户刷新/访问行为"></a>用户刷新/访问行为</h3><ul>
<li>在URI输入栏中输入然后回车/通过书签访问，这讲触发缓存机制</li>
<li>F5/点击工具栏中的刷新按钮/右键菜单重新加载，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断 </li>
<li>Ctl+F5，跳过强缓存和协商缓存，直接从服务器拉取资源 </li>
</ul>
]]></content>
      <tags>
        <tag>HTTP,浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Java HashMap</title>
    <url>/2018/08/20/ckybpqxgl000sd2nhd0a1bjds/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>HashMap是Java集合中重要的一个数据结构，作为<code>key-value</code>形式的存在，被广泛使用</p>
<p>虽在平常开发中经常使用HashMap来存放数据，并且很多框架也使用了Map，但对HashMap的了解一直不够深入</p>
<h1 id="HashMap在JDK-1-7中的实现"><a href="#HashMap在JDK-1-7中的实现" class="headerlink" title="HashMap在JDK 1.7中的实现"></a>HashMap在JDK 1.7中的实现</h1><a id="more"></a>
<h2 id="1-7中的数据结构"><a href="#1-7中的数据结构" class="headerlink" title="1.7中的数据结构"></a>1.7中的数据结构</h2><p><img src="/2018/08/20/ckybpqxgl000sd2nhd0a1bjds/HashMap1.7中的数据结构.png" alt=""></p>
<h2 id="1-7中HashMap几个关键的成员变量"><a href="#1-7中HashMap几个关键的成员变量" class="headerlink" title="1.7中HashMap几个关键的成员变量"></a>1.7中HashMap几个关键的成员变量</h2><p><img src="/2018/08/20/ckybpqxgl000sd2nhd0a1bjds/HashMap1.7中关键的成员变量.png" alt=""></p>
<ol>
<li>初始化桶大小，因为底层是数组，所以这是数组默认的大小。</li>
<li>桶最大值。</li>
<li>默认的负载因子（0.75）</li>
<li><code>table</code> 真正存放数据的数组。</li>
<li><code>Map</code> 存放数量的大小。</li>
<li>桶大小，可在初始化时显式指定。</li>
<li>负载因子，可在初始化时显式指定</li>
</ol>
<h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 <code>16 * 0.75 = 12</code> 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作</p>
<h2 id="Entry类"><a href="#Entry类" class="headerlink" title="Entry类"></a>Entry类</h2><p>Entry 是 HashMap 中的一个内部类，从他的成员变量很容易看出：</p>
<ul>
<li>key 就是写入时的键。</li>
<li>value 自然就是值。</li>
<li>开始的时候就提到 HashMap 是由数组和链表组成，所以这个 next 就是用于实现链表结构。</li>
<li>hash 存放的是当前 key 的 hashcode。</li>
</ul>
<h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put 操作的流程</p>
<ul>
<li>判断当前数组是否需要初始化。</li>
<li>如果 key 为空，则 put 一个空值进去。</li>
<li>根据 key 计算出 hashcode。</li>
<li>根据计算出的 hashcode 定位出所在桶。</li>
<li>如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。</li>
<li>如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。</li>
</ul>
<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。</li>
<li>判断该位置是否为链表。</li>
<li>不是链表就根据 <code>key、key 的 hashcode</code> 是否相等来返回值。</li>
<li>为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。</li>
<li>啥都没取到就直接返回 null </li>
</ul>
<h1 id="HashMap在JDK-1-8中的实现"><a href="#HashMap在JDK-1-8中的实现" class="headerlink" title="HashMap在JDK 1.8中的实现"></a>HashMap在JDK 1.8中的实现</h1><p>1.7中HashMap有一个问题就是，当Hash严重冲突时，链表就会越来越长，查找的效率就会越来越低</p>
<p>因此在1.8中就优化了这个问题</p>
<h2 id="1-8中的数据结构"><a href="#1-8中的数据结构" class="headerlink" title="1.8中的数据结构"></a>1.8中的数据结构</h2><p><img src="/2018/08/20/ckybpqxgl000sd2nhd0a1bjds/HashMap1.8中的数据结构.png" alt=""></p>
<h2 id="1-8中HashMap关键成员变量"><a href="#1-8中HashMap关键成员变量" class="headerlink" title="1.8中HashMap关键成员变量"></a>1.8中HashMap关键成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<p>和1.7中的区别</p>
<ul>
<li><code>TREEIFY_THRESHOLD</code> 用于判断是否需要将链表转换为红黑树的阈值。</li>
<li>HashEntry 修改为 <code>Node</code>，Node核心组成和1.7中的Entry一致</li>
</ul>
<h2 id="put-方法-1"><a href="#put-方法-1" class="headerlink" title="put 方法"></a>put 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。</li>
<li>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。</li>
<li>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 <code>key、key 的 hashcode</code> 与写入的 key 是否相等，相等就赋值给 <code>e</code>,在第 8 步的时候会统一进行赋值及返回。</li>
<li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</li>
<li>如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。</li>
<li>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li>
<li>如果在遍历过程中找到 key 相同时直接退出遍历。</li>
<li>如果 <code>e != null</code> 就相当于存在相同的 key,那就需要将值覆盖。</li>
<li>最后判断是否需要进行扩容</li>
</ol>
<h2 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get 方法"></a>get 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先将 key hash 之后取得所定位的桶。</li>
<li>如果桶为空则直接返回 null 。</li>
<li>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。</li>
<li>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</li>
<li>红黑树就按照树的查找方式返回值。</li>
<li>不然就按照链表的方式遍历匹配返回值。</li>
</ul>
<h1 id="HashMap存在的问题"><a href="#HashMap存在的问题" class="headerlink" title="HashMap存在的问题"></a>HashMap存在的问题</h1><p>HashMap问题之一就是在并发情况下可能会出现死循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            map.put(UUID.randomUUID().toString(), <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">        System.out.println(<span class="string">"key="</span> + next.getKey() + <span class="string">" value="</span> + next.getValue());</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        String key = iterator.next();</span><br><span class="line">        System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议使用第一种方式遍历，可以一次取出key和value</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2018/09/04/ckybpqxgm000td2nh1k8b90kd/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力，但频繁的创建线程的开销是很大的，那么如何来减少这部分的开销了，那么就要考虑使用线程池了。线程池就是一个线程的容器，每次只执行额定数量的线程，线程池就是用来管理这些额定数量的线程</p>
<h4 id="线程池相关类结构图"><a href="#线程池相关类结构图" class="headerlink" title="线程池相关类结构图"></a>线程池相关类结构图</h4><a id="more"></a>
<p><img src="/2018/09/04/ckybpqxgm000td2nh1k8b90kd/ExecutorService接口关系图.png" alt=""></p>
<p><code>ExecutorService</code>继承了<code>Executor</code>接口</p>
<p><code>Executor</code>接口中的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">The &#123;<span class="meta">@code</span> Executor&#125; implementations provided in <span class="keyword">this</span> <span class="keyword">package</span></span><br><span class="line">implement &#123;<span class="meta">@link</span> ExecutorService&#125;, which is a more extensive</span><br><span class="line"><span class="class"><span class="keyword">interface</span>.  <span class="title">The</span> </span>&#123;<span class="meta">@link</span> ThreadPoolExecutor&#125; <span class="class"><span class="keyword">class</span> <span class="title">provides</span> <span class="title">an</span></span></span><br><span class="line"><span class="class"><span class="title">extensible</span> <span class="title">thread</span> <span class="title">pool</span> <span class="title">implementation</span>. <span class="title">The</span> </span>&#123;<span class="meta">@link</span> Executors&#125; <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">provides</span> <span class="title">convenient</span> <span class="title">factory</span> <span class="title">methods</span> <span class="title">for</span> <span class="title">these</span> <span class="title">Executors</span>.</span></span><br></pre></td></tr></table></figure>
<p>根据JDK源码中的注释：<code>ExecutorService</code>是对<code>Executor</code>扩展的一个接口，<code>ThreadPoolExecutor</code>类提供了对<code>ExecutorService</code>的实现，<code>Executors</code>类提供了方便的工厂方法</p>
<h4 id="如何创建一个线程池"><a href="#如何创建一个线程池" class="headerlink" title="如何创建一个线程池"></a>如何创建一个线程池</h4><h5 id="使用Executors工厂类来创建"><a href="#使用Executors工厂类来创建" class="headerlink" title="使用Executors工厂类来创建"></a>使用Executors工厂类来创建</h5><p>Executors提供了几种创建线程池的方法：</p>
<p><img src="/2018/09/04/ckybpqxgm000td2nh1k8b90kd/Executors工厂类的方法.png" alt=""></p>
<p>1） 创建固定大小的线程池<code>newFixedThreadPool</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">        Runnable task = <span class="keyword">new</span> myTask();</span><br><span class="line">        pool.submit(task);   <span class="comment">// submit方法内部会调用execute方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行........"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>正在执行........</span><br></pre></td></tr></table></figure>
<p>2） 单线程的线程池<code>newSignleThreadExecutor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService pool = Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        Runnable task = <span class="keyword">new</span> myTask();</span><br><span class="line">        pool.submit(task);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br></pre></td></tr></table></figure>
<p>单线程的线程池:这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行</p>
<p>3）<code>newScheduledThreadPool</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    pool.schedule(<span class="keyword">new</span> myTask(), <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    pool.schedule(<span class="keyword">new</span> myTask(), <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    pool.shutdown();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.currentThread().join(<span class="number">5000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">等待<span class="number">1</span>s后</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行........</span><br><span class="line">等待<span class="number">1</span>s后</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br></pre></td></tr></table></figure>
<p>4) 可以缓存的线程池<code>newCachedThreadPool</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">        Runnable task = <span class="keyword">new</span> myTask();</span><br><span class="line">        pool.submit(task);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">13</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">14</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">16</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">12</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">17</span>正在执行........</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">15</span>正在执行........</span><br></pre></td></tr></table></figure>
<p><code>newCachedThreadPool</code>内部调用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可缓存的线程池：如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制</p>
<p>官方建议程序员使用较为方便的<code>Executors</code>工厂方法<code>Executors.newCachedThreadPool</code>()（无界线程池，可以进行自动线程回收）、<code>Executors.newFixedThreadPool(int)</code>（固定大小线程池）<code>Executors.newSingleThreadExecutor()</code>（单个后台线程），这几种线程池均为大多数使用场景预定义了默认配置。</p>
<h5 id="继承ThreadPoolExecutor类，并复写父类的构造方法"><a href="#继承ThreadPoolExecutor类，并复写父类的构造方法" class="headerlink" title="继承ThreadPoolExecutor类，并复写父类的构造方法"></a>继承ThreadPoolExecutor类，并复写父类的构造方法</h5><p><code>ThreadPoolExecutor</code>的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的<code>Executors</code>工厂类中创建线程池的几个工厂方法内部都是调用了此构造方法</p>
<p>先看看这个构造方法的参数的含义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">corePoolSize--池中所保存的线程数，包括空闲线程。</span><br><span class="line">maximumPoolSize--池中允许的最大线程数。</span><br><span class="line">keepAliveTime--当线程数大于corePoolSize时，此为终止空闲线程等待新任务的最长时间。</span><br><span class="line">Unit--keepAliveTime 参数的时间单位。</span><br><span class="line">workQueue--执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务。</span><br><span class="line">threadFactory--执行程序创建新线程时使用的工厂。</span><br><span class="line">Handler--由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。</span><br></pre></td></tr></table></figure>
<p>这几个参数之间的关系</p>
<p>接下来，咋们来说下这几个参数之间的关系。当线程池刚创建的时候，线程池里面是没有任何线程的(注意，并不是线程池一创建，里面就创建了一定数量的线程)，当调用execute()方法添加一个任务时，线程池会做如下的判断：</p>
<ol>
<li>如果当前正在运行的线程数量小于corePoolSize，那么立刻创建一个新的线程，执行这个任务。</li>
<li>如果当前正在运行的线程数量大于或等于corePoolSize，那么这个任务将会放入队列中。</li>
<li>如果线程池的队列已经满了，但是正在运行的线程数量小于maximumPoolSize，那么还是会创建新的线程，执行这个任务。</li>
<li>如果队列已经满了，且当前正在运行的线程数量大于或等于maximumPoolSize，那么线程池会根据拒绝执行策略来处理当前的任务。</li>
<li>当一个任务执行完后，线程会从队列中取下一个任务来执行，如果队列中没有需要执行的任务，那么这个线程就会处于空闲状态，如果超过了keepAliveTime存活时间，则这个线程会被线程池回收(注：回收线程是有条件的，如果当前运行的线程数量大于corePoolSize的话，这个线程就会被销毁，如果不大于corePoolSize，是不会销毁这个线程的，线程的数量必须保持在corePoolSize数量内).为什么不是线程一空闲就回收，而是需要等到超过keepAliveTime才进行线程的回收了，原因很简单：因为线程的创建和销毁消耗很大，更不能频繁的进行创建和销毁，当超过keepAliveTime后，发现确实用不到这个线程了，才会进行销毁。这其中unit表示keepAliveTime的时间单位，unit的定义如下：</li>
</ol>
<h4 id="线程池队列BlockingQueue"><a href="#线程池队列BlockingQueue" class="headerlink" title="线程池队列BlockingQueue"></a>线程池队列<code>BlockingQueue</code></h4><p>类结构图</p>
<p><img src="/2018/09/04/ckybpqxgm000td2nh1k8b90kd/线程池队列BlockingQueue类结构图.png" alt=""></p>
<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>该队列对应的就是上面所说的直接提交，首先SynchronousQueue是无界的，也就是说他存数任务的能力是没有限制的，但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加</p>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>有界队列</p>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with the given (fixed) capacity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is not greater</span></span><br><span class="line"><span class="comment">     *         than zero</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125;, initially containing the elements of the</span></span><br><span class="line"><span class="comment">     * given collection,</span></span><br><span class="line"><span class="comment">     * added in traversal order of the collection's iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection of elements to initially contain</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment">     *         of its elements are null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        putLock.lock(); <span class="comment">// Never contended, but necessary for visibility</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">                <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">                enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            count.set(n);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>有界队列</p>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an &#123;<span class="doctag">@code</span> ArrayBlockingQueue&#125; with the given (fixed)</span></span><br><span class="line"><span class="comment">     * capacity and the specified access policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair if &#123;<span class="doctag">@code</span> true&#125; then queue accesses for threads blocked</span></span><br><span class="line"><span class="comment">     *        on insertion or removal, are processed in FIFO order;</span></span><br><span class="line"><span class="comment">     *        if &#123;<span class="doctag">@code</span> false&#125; the access order is unspecified.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity &lt; 1&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(capacity, fair);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock(); <span class="comment">// Lock only for visibility, not mutual exclusion</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                    checkNotNull(e);</span><br><span class="line">                    items[i++] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            &#125;</span><br><span class="line">            count = i;</span><br><span class="line">            putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>fair</code>表示队列获取线程的策略是FIFO还是无序</p>
<p>####　线程池的拒绝执行策略</p>
<p>当线程的数量达到最大值时，这个时候，任务还在不断的来，这个时候，就只好拒绝接受任务了</p>
<p><code>ThreadPoolExecutor</code> 允许自定义当添加任务失败后的执行策略。你可以调用线程池的 <code>setRejectedExecutionHandler()</code>方法，用自定义的<code>RejectedExecutionHandler</code> 对象替换现有的策略<code>ThreadPoolExecutor</code>提供的默认的处理策略是直接丢弃，同时抛异常信息，<code>ThreadPoolExecutor</code> 提供 4 个现有的策略，分别是：</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy：表示拒绝任务并抛出异常</li>
<li>ThreadPoolExecutor.DiscardPolicy：表示拒绝任务但不做任何动作</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：表示拒绝任务，并在调用者的线程中直接执行该任务</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：表示先丢弃任务队列中的第一个任务，然后把这个任务加进队列</li>
</ul>
]]></content>
      <tags>
        <tag>线程池，Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven依赖，去哪儿找你呢？</title>
    <url>/2021/08/29/ckybpqxgp000wd2nh099mcva5/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210829143616546.png" alt="" style="width:100%"></p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p><code>maven</code>是作为<code>Javer</code>日常开发中必不可少的工具，但是很多人对于它的使用也只是仅限于的几个功能。</p>
<p>前几天在使用一个依赖总是说找不到该依赖，但是在中央仓库中的确存在该构建。这个问题让我很困惑，突然发现对于maven这个优秀构建工具的使用也只是浮于表面。痛定思痛，于是就有了这篇简短的总结。</p>
<blockquote>
<p>对于maven依赖顺序的搜索，网上众说纷纭，那么真相到底是怎么样的呢？</p>
</blockquote>
<a id="more"></a>
<h1 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h1><p>根据我们的开发经验，使用maven可以配置多个仓库，先来看看我们最熟悉的一个。</p>
<p>打开我们的settings.xml文件,一开始是一个最纯洁的配置文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210826221331089.png" alt="image-20210826221331089"></p>
<p>可以看到，只是配置了一个镜像地址和一个本地仓库的路径，这也是我们第一次使用maven时大多数教程中会提到的一点-修改mirror为国内的一个地址。</p>
<p>现在我们创建一个maven的工程，然后看看它的依赖查找顺序是怎样的？</p>
<p>我创建了一个<code>mvn-dep</code>文件夹，在这里面创建项目所需要的文件，为了简单，我就使用maven cli来搭建一个简单的项目，使用的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp  -DinteractiveMode=true -DgroupId=com.watertreestar -DartifactId=mvn-dep -Dversion=1.0 -Dpackage=com.watertreestar</span><br></pre></td></tr></table></figure>
<p>创建好以后我们的项目结构如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210826222721918.png" alt=""></p>
<p>接下来看一下不同的配置下依赖查找的路径</p>
<h1 id="3-依赖查找探索"><a href="#3-依赖查找探索" class="headerlink" title="3. 依赖查找探索"></a>3. 依赖查找探索</h1><p>使用上一步创建的项目，并在上面的基础settings.xml配置文件上做修改，观察依赖查找的优先级。</p>
<p>在操作之前，我们在项目的pom.xml中已经包含了一个依赖就是fastjson</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.78<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们先确保本地仓库中该版本的junit不存在,使用<code>rm</code>命令来删除它:</p>
<p><code>rm -rf  ~/.m2/repository/com/alibaba/fastjson</code></p>
<h2 id="3-1-不修改的情况"><a href="#3-1-不修改的情况" class="headerlink" title="3.1 不修改的情况"></a>3.1 不修改的情况</h2><p>我们使用上面的setings.xml文件，不做任何修改,执行<code>mvn compile</code>命令,输出如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210829143616546.png" alt="image-20210829143616546"></p>
<p>可以看出，maven是从我们配置的central镜像-阿里云镜像中拉取依赖</p>
<h2 id="3-2-没有配置中央仓库镜像"><a href="#3-2-没有配置中央仓库镜像" class="headerlink" title="3.2 没有配置中央仓库镜像"></a>3.2 没有配置中央仓库镜像</h2><p>现在我们把settings文件中的mirror配置删除,就成了一个光秃秃的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span><span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxies</span>&gt;</span><span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/Users/young/.m2/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，依赖会从哪儿获取呢</p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210829143812267.png" alt="image-20210829143812267"></p>
<p>可以看到，是从默认的中央仓库中查找和下载依赖。</p>
<p>根据上面的结果可以看到优先级：</p>
<blockquote>
<p>特定仓库reporitory的镜像mirror &gt; settings中配置的仓库repository </p>
</blockquote>
<h2 id="3-3-项目配置仓库repository"><a href="#3-3-项目配置仓库repository" class="headerlink" title="3.3 项目配置仓库repository"></a>3.3 项目配置仓库repository</h2><ol>
<li>现在我们把仓库的配置还原到最初的状态，如下：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span><span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">proxies</span>&gt;</span><span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/Users/young/.m2/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>settings-mirror<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>然后在第二节中创建的项目pom.xml文件中添加一个repository配置,我们使用了一个sonatype的maven仓库</p>
<p>当前的<code>项目pom.xml配置</code>如下:</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.78<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>pom_repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>sonatype<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.sonatype.org/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行<code>mvn compile</code>命令，输出如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picpicimage-20210829151337364.png" alt=""></p>
<p>可以看出依赖从项目pom.xml配置的pom-repository仓库中查找并下载。</p>
<h2 id="3-4-配置全局profile中的repository"><a href="#3-4-配置全局profile中的repository" class="headerlink" title="3.4 配置全局profile中的repository"></a>3.4 配置全局profile中的repository</h2><p>在maven配置文件settings.xml中增加profile配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210826235027569.png" alt="image-20210826235027569"></p>
<p>使用<code>maven compile -Psettings-profile</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210829151813952.png" alt="image-20210829151813952"></p>
<p>可以看出，依赖从settings.xml中我们配置settings-profile的repository中下载的</p>
<blockquote>
<p>settings_profile_repository &gt; pom_repositories</p>
</blockquote>
<h2 id="3-5-配置项目profile的repository"><a href="#3-5-配置项目profile的repository" class="headerlink" title="3.5 配置项目profile的repository"></a>3.5 配置项目profile的repository</h2><h3 id="3-5-1-激活pom中的profile和setting中的profile"><a href="#3-5-1-激活pom中的profile和setting中的profile" class="headerlink" title="3.5.1 激活pom中的profile和setting中的profile"></a>3.5.1 激活pom中的profile和setting中的profile</h3><p>全局settings.xml中的配置不见，在pom.xml中增加profile配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>pom-profile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>pom-profile-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>maven2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>删除本地仓库的fastjson依赖，然后执行<code>mvn compile -Psettings-profile,pom-profile</code></p>
<p>输出：</p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210829153530950.png" alt="image-20210829153530950"></p>
<p>我们同时激活了settings-profile和pom-profile,但是最终依赖的下载是从settings-profile中配置的仓库下载的。</p>
<blockquote>
<p>settings-profile &gt; pom-profile</p>
</blockquote>
<h3 id="3-5-2-只是激活pom中的profile"><a href="#3-5-2-只是激活pom中的profile" class="headerlink" title="3.5.2 只是激活pom中的profile"></a>3.5.2 只是激活pom中的profile</h3><p>假如只是激活pom中的profile,也就是使用<code>mvn compile -Ppom-profile</code>,输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210829153952948.png" alt="image-20210829153952948"></p>
<p>可以看出，最终依赖的下载是从pom中配置的profile-repository中下载的</p>
<blockquote>
<p>pom-profile-repository &gt; pom-repository</p>
</blockquote>
<h2 id="3-6-local-repository"><a href="#3-6-local-repository" class="headerlink" title="3.6 local repository"></a>3.6 local repository</h2><p>由于之前的步骤中我们已经下载jar到了local仓库，为了测试最后一步，我们就不用在执行<code>rm -rf ~/.m2/repository/com/alibaba/fastjson</code>来删除本地的依赖了。</p>
<p>我这里使用了<code>mvn compile -Ppom-profile</code>来做测试，输出的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/watertreestar/CDN@master/picimage-20210829154538769.png" alt="image-20210829154538769"></p>
<p>可以看到，没有从任何远程仓库中下载依赖</p>
<blockquote>
<p>local &gt; 所有远程仓库</p>
</blockquote>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>从上面一系列的验证中可以总结出依赖查找的优先级：</p>
<blockquote>
<p> local-repo &gt; settings-profile-repository &gt; pom-profile-repository &gt; pom-repository &gt;  central</p>
</blockquote>
<p>理解maven查找的优先级，可以帮助我们在工作和学习中解决一些依赖找不到的错误。</p>
<p>最后，推荐几个可以使用的maven仓库：</p>
<ul>
<li><a href="https://repo.maven.apache.org/maven2/" target="_blank" rel="noopener">https://repo.maven.apache.org/maven2/</a></li>
<li><a href="https://repo1.maven.org/maven2/" target="_blank" rel="noopener">https://repo1.maven.org/maven2/</a></li>
<li><a href="https://maven.aliyun.com/repository/public" target="_blank" rel="noopener">https://maven.aliyun.com/repository/public</a></li>
</ul>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis入门</title>
    <url>/2018/07/12/ckybpqxgq000xd2nhazxq18og/</url>
    <content><![CDATA[<h4 id="1-MyBatis-简介"><a href="#1-MyBatis-简介" class="headerlink" title="1. MyBatis 简介"></a>1. MyBatis 简介</h4><ul>
<li>MyBatis是一个优秀的<strong>持久层框架</strong>，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。</li>
<li>Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回</li>
</ul>
<a id="more"></a>
<h4 id="2-MyBatis架构"><a href="#2-MyBatis架构" class="headerlink" title="2. MyBatis架构"></a>2. MyBatis架构</h4><p> <img src="/2018/07/12/ckybpqxgq000xd2nhazxq18og/MyBatis架构.png" alt=""></p>
<h5 id="MyBatis配置"><a href="#MyBatis配置" class="headerlink" title="MyBatis配置"></a>MyBatis配置</h5><ul>
<li>SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息、</li>
<li>mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载</li>
</ul>
<h5 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h5><p> 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂</p>
<h5 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h5><p>由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。</p>
<h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。</p>
<h5 id="Mapped-Statement"><a href="#Mapped-Statement" class="headerlink" title="Mapped Statement"></a>Mapped Statement</h5><p>Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id</p>
<p>Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数</p>
<p>Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。</p>
<h4 id="3-MyBatis框架搭建"><a href="#3-MyBatis框架搭建" class="headerlink" title="3. MyBatis框架搭建"></a>3. MyBatis框架搭建</h4><ol>
<li><p>导包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.18.2-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.ow2.asm/asm --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ow2.asm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>asm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>建立数据库表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</span><br><span class="line"><span class="string">`birthday`</span> <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'生日'</span>,</span><br><span class="line"><span class="string">`sex`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line"><span class="string">`address`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'地址'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">27</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>创建User实体类，对应数据库中的user</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String username;<span class="comment">// 用户姓名</span></span><br><span class="line"><span class="keyword">private</span> String sex;<span class="comment">// 性别</span></span><br><span class="line"><span class="keyword">private</span> Date birthday;<span class="comment">// 生日</span></span><br><span class="line"><span class="keyword">private</span> String address;<span class="comment">// 地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>核心配置文件<code>sqlMapConfig.xml</code>(src目录下)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和spring整合后 environments配置将废除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用jdbc事务管理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/spring?characterEncoding=utf-8"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>日志文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Console output...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] - %m%n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mapper.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace：命名空间，用于隔离sql, </span></span><br><span class="line"><span class="comment">命名空间 user.findUserById</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过ID查询一个用户 </span></span><br><span class="line"><span class="comment"> id名字，namespace+id用来定位具体的sql   parameterType：参数类型   resultType：返回值，如果bean与数据库一一对应，则会自动映射   where id=#&#123;v&#125;，#&#123;&#125; 占位符，里面要写一个任意字符</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">parameterType</span>=<span class="string">"Integer"</span> <span class="attr">resultType</span>=<span class="string">"com.ali.pojo.User"</span>&gt;</span></span><br><span class="line">    select * from t_user where id=#&#123;v&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时，在核心配置文件中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapper位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"../src/sqlMap/User.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMybatis</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//加载核心文件</span></span><br><span class="line">        String resource=<span class="string">"sqlMapConfig.xml"</span>;</span><br><span class="line">        InputStream resourceAsStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="comment">//创建sqlSessionFactory</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory=<span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">        <span class="comment">//创建sqlSession</span></span><br><span class="line">        SqlSession session=sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//执行sql语句</span></span><br><span class="line">        User user = session.selectOne(<span class="string">"user.findUserById"</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据名字模糊查询</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据名字模糊查询</span></span><br><span class="line"><span class="comment">        #&#123;&#125;  1.相当于？   =='' 会带单引号   2.里面的表示字符任意</span></span><br><span class="line"><span class="comment">        $&#123;&#125;     1.不带单引号    2.里面的字符必须为value</span></span><br><span class="line"><span class="comment">        resultType="com.pojo.User"  写的是list的泛型</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByName"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"com.ali.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  select * from t_user where name like '%$&#123;value&#125;%'--&gt;</span></span><br><span class="line">    select * from t_user where name like "%"#&#123;v&#125;"%"</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码：<code>List&lt;User&gt; users = session.selectList(&quot;user.findUserByNames&quot;, &quot;ba&quot;);</code></p>
</li>
<li><p>添加用户</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.bean.User"</span>&gt;</span></span><br><span class="line">        insert into t_user values(null,#&#123;name&#125;,#&#123;sex&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加用户返回id</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.ali.bean.User"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"Integer"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span>&gt;</span></span><br><span class="line">        select LAST_INSERT_ID()<span class="comment">&lt;!-- 这个是mysql提供的函数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into t_user values(null,#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user=<span class="keyword">new</span> User();</span><br><span class="line">user.setName(<span class="string">"ali"</span>);</span><br><span class="line">user.setAge(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">int</span> insert = openSession.insert(<span class="string">"user.insertUser"</span>, user);</span><br><span class="line">openSession.commit();</span><br><span class="line">System.out.println(user.getId());</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新用户</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.bean.User"</span>&gt;</span></span><br><span class="line">    update t_user set name=#&#123;name&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除用户</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.bean.User"</span>&gt;</span></span><br><span class="line">        delete from t_user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结论</p>
<ul>
<li><code>`</code><ul>
<li>#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换。#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。</li>
<li>${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${} 括号中只能是value。<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      - 单个简单类型  `#&#123;&#125;`可以写任意值或者`<span class="keyword">value</span>`,如果是pojo，则要对应pojo中的属性值</span><br><span class="line">      - 单个简单类型`$&#123;&#125;`只能写<span class="keyword">value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Hibernate和MyBatis简单比较</span><br><span class="line"></span><br><span class="line">- Mybatis和hibernate不同，它不完全是一个ORM框架，`因为MyBatis需要程序员自己编写<span class="keyword">Sql</span>语句`。mybatis可以通过<span class="type">XML</span>或注解方式灵活配置要运行的<span class="keyword">sql</span>语句，并将java对象和<span class="keyword">sql</span>语句映射生成最终执行的<span class="keyword">sql</span>，最后将<span class="keyword">sql</span>执行的结果再映射生成java对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- `Mybatis学习门槛低，简单易学，程序员直接编写原生态<span class="keyword">sql</span>`，可严格控制<span class="keyword">sql</span>执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套<span class="keyword">sql</span>映射文件，工作量大。</span><br><span class="line">- `Hibernate对象/关系映射能力强，数据库无关性好`，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### MyBatis开发方法</span><br><span class="line"></span><br><span class="line">##### DAO开发方法</span><br><span class="line"></span><br><span class="line">- dao层建立UserDao和UserDaoImpl</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="built_in">public</span> <span class="keyword">class</span> UserDaoImpl implements UserDao &#123;</span><br><span class="line"></span><br><span class="line">  //注入工厂</span><br><span class="line">  private SqlSessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">public</span> UserDaoImpl(SqlSessionFactory sessionFactory) &#123;</span><br><span class="line">      this.sessionFactory = sessionFactory;</span><br><span class="line">  &#125;</span><br><span class="line">  //通过用户ID查询一个用户</span><br><span class="line">    @Override</span><br><span class="line">  <span class="built_in">public</span> <span class="keyword">User</span> selectUserById(<span class="type">Integer</span> id) &#123;</span><br><span class="line">      SqlSession openSession = sessionFactory.openSession();</span><br><span class="line">      <span class="keyword">return</span> openSession.selectOne("user.findUserById",id);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisDaoTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String resource=<span class="string">"sqlMapConfig.xml"</span>;</span><br><span class="line">    InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">    sqlSessionFactory=<span class="keyword">new</span> SqlSessionFactoryBuilder().build(in); </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserDao userDao =<span class="keyword">new</span> UserDaoImpl(sqlSessionFactory);</span><br><span class="line">    User user = userDao.selectUserById(<span class="number">2</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Mapper动态代理开发"><a href="#Mapper动态代理开发" class="headerlink" title="Mapper动态代理开发"></a>Mapper动态代理开发</h5><ul>
<li><p>只写接口，实现类由mybatis生成</p>
</li>
<li><p>四个原则：Mapper接口开发需要遵循以下规范</p>
<p>1、 Mapper.xml文件中的namespace与mapper接口的类路径相同。</p>
<p>2、 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</p>
<p>3、 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</p>
<p>4、 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p>
</li>
<li><p>示例</p>
<ul>
<li><p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ali.mapper;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MapperUser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原则一：mapper.xml中的namespace要与mapper接口类路径相同</span></span><br><span class="line">    <span class="comment">//原则二：接口方法名与xml中id相同</span></span><br><span class="line">    <span class="comment">//原则三：接口的输入参数一致</span></span><br><span class="line">    <span class="comment">//原则四：接口方法返回类型一致</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mapper.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mapper.MapperUser"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserById"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.User"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">"Integer"</span>&gt;</span></span><br><span class="line">        select * from t_user where id=#&#123;v&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  String resource=<span class="string">"sqlMapConfig.xml"</span>;</span><br><span class="line">  InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">  SqlSessionFactory sqlSessionFactory=<span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">  SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">  <span class="comment">//sqlSession生成实现类</span></span><br><span class="line">  MapperUser userMapper = sqlSession.getMapper(MapperUser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  User user = userMapper.findUserById(<span class="number">2</span>);</span><br><span class="line">  System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis配置文件</title>
    <url>/2018/09/02/ckybpqxgr0010d2nhhc150lfl/</url>
    <content><![CDATA[<p>我们可以在启动redis服务器的时候指定配置文件</p>
<p>redis配置文件<code>redis.con</code>在开始的时候，先明确了一些单位</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br></pre></td></tr></table></figure>
<p>redis支持从外部文件中引入配置文件</p>
<a id="more"></a>
<p><code>include /path/to/other.conf</code></p>
<p>redis的配置文件中分成了几个部分：</p>
<ul>
<li>通用(general)</li>
<li>快照(snapshotting)</li>
<li>复制(replicaion)</li>
<li>安全(security)</li>
<li>限制(limits)</li>
<li>追加模式(AOF)</li>
<li>LUA脚本(LUA script)</li>
<li>慢日志(slow log)</li>
<li>事件通知(event notification)</li>
</ul>
<h1 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h1><p>默认情况下，redis并不是以daemon形式来运行的。通过daemonize配置项可以控制redis的运行形式，如果改为yes，那么redis就会以daemon形式运行：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">daemonize</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，redis会响应本机所有可用网卡的连接请求。当然，redis允许你通过bind配置项来指定要绑定的IP</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">bind <span class="number">192.168</span><span class="number">.1</span><span class="number">.2</span> <span class="number">10.8</span><span class="number">.4</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>
<p>redis的默认服务端口是6379，你可以通过port配置项来修改。如果端口设置为0的话，redis便不会监听端口了。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">port <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<p>当一个redis-client一直没有请求发向server端，那么server端有权主动关闭这个连接，可以通过timeout来设置“空闲超时时限”，0表示永不关闭</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">timeout <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>TCP连接保活策略，可以通过tcp-keepalive配置项来进行设置，单位为秒，假如设置为60秒，则server端会每60秒向连接空闲的客户端发起一次ACK请求，以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。如果设置为0，则不会进行保活检测。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">tcp-keepalive <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>redis支持通过loglevel配置项设置日志等级，共分四级，即debug、verbose、notice、warning。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">loglevel</span> <span class="literal">notice</span></span><br></pre></td></tr></table></figure>
<p>redis也支持通过logfile配置项来设置日志文件的生成位置。如果设置为空字符串，则redis会将日志输出到标准输出。假如你在daemon情况下将日志设置为输出到标准输出，则日志会被写到/dev/null中。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">logfile</span> <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>对于redis来说，可以设置其数据库的总数量，假如你希望一个redis包含16个数据库，那么设置如下：</p>
<blockquote>
<p>这16个数据库的编号将是0到15。默认的数据库是编号为0的数据库。用户可以使用select <DBid>来选择相应的数据库。</DBid></p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">databases <span class="number">16</span></span><br></pre></td></tr></table></figure>
<h1 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h1><p>快照，主要涉及的是redis的RDB持久化相关的配置</p>
<p>我们可以用如下的指令来让数据保存到磁盘上，即控制RDB快照功能：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">save <span class="number">60</span> <span class="number">500</span>      </span><br><span class="line">#  <span class="number">60</span> 秒内至少有<span class="number">500</span>个<span class="type">key</span>发生改变，就触发一次快照持久化</span><br></pre></td></tr></table></figure>
<p>如果你想禁用RDB持久化的策略，只要不设置任何save指令就可以，或者给save传入一个空字符串参数也可以达到相同效果，</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">save</span> <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>如果用户开启了RDB快照功能，那么在redis持久化数据到磁盘时如果出现失败，默认情况下，redis会停止接受所有的写请求。这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。如果redis不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。</p>
<p>如果下一次RDB持久化成功，redis会自动恢复接受写请求。</p>
<p>当然，如果你不在乎这种数据不一致或者有其他的手段发现和控制这种不一致的话，你完全可以关闭这个功能，以便在快照写入失败时，也能确保redis继续接受新的写请求。配置项如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">stop-writes-<span class="keyword">on</span>-bgsave-<span class="keyword">error</span> yes</span><br></pre></td></tr></table></figure>
<p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rdbcompression</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<p>我们还可以设置快照文件的名称，默认是这样配置的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dbfilename</span> <span class="selector-tag">dump</span><span class="selector-class">.rdb</span></span><br></pre></td></tr></table></figure>
<p>最后，你还可以设置这个快照文件存放的路径。比如默认设置就是当前文件夹：</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> ./</span><br></pre></td></tr></table></figure>
<h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>redis提供了主从同步功能。</p>
<p>通过slaveof配置项可以控制某一个redis作为另一个redis的从服务器，通过指定IP和端口来定位到主redis的位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">slaveof <span class="tag">&lt;<span class="name">masterip</span>&gt;</span> <span class="tag">&lt;<span class="name">masterport</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果主redis设置了验证密码的话（使用requirepass来设置），则在从redis的配置中要使用masterauth来设置校验密码，否则的话，主redis会拒绝从redis的访问请求。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">masterauth <span class="tag">&lt;<span class="name">master-password</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当从redis失去了与主redis的连接，或者主从同步正在进行中时，redis该如何处理外部发来的访问请求呢？这里，从redis可以有两种选择：</p>
<p>第一种选择：如果slave-serve-stale-data设置为yes（默认），则从redis仍会继续响应客户端的读写请求。</p>
<p>第二种选择：如果slave-serve-stale-data设置为no，则从redis会对客户端的请求返回“SYNC with master in progress”，当然也有例外，当客户端发来INFO请求和SLAVEOF请求，从redis还是会进行处理。</p>
<p>你可以控制一个从redis是否可以接受写请求。将数据直接写入从redis，一般只适用于那些生命周期非常短的数据，因为在主从同步时，这些临时数据就会被清理掉。自从redis2.6版本之后，默认从redis为只读。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="literal">slave</span>-<span class="keyword">read</span>-only yes</span><br></pre></td></tr></table></figure>
<p>只读的从redis并不适合直接暴露给不可信的客户端。为了尽量降低风险，可以使用rename-command指令来将一些可能有破坏力的命令重命名，避免外部直接调用。比如</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">rename-command<span class="built_in"> CONFIG </span>b840fc02d524045429941cc15f59e41cb7be6c52</span><br></pre></td></tr></table></figure>
<p>从redis会周期性的向主redis发出PING包。你可以通过repl_ping_slave_period指令来控制其周期。默认是10秒。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">repl-ping-slave-period <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>在主从同步时，可能在这些情况下会有超时发生：</p>
<p>1.以从redis的角度来看，当有大规模IO传输时。<br>2.以从redis的角度来看，当数据传输或PING时，主redis超时<br>3.以主redis的角度来看，在回复从redis的PING时，从redis超时</p>
<p>用户可以设置上述超时的时限，不过要确保这个时限比repl-ping-slave-period的值要大，否则每次主redis都会认为从redis超时。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">repl-timeout <span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>我们可以控制在主从同步时是否禁用TCP_NODELAY。如果开启TCP_NODELAY，那么主redis会使用更少的TCP包和更少的带宽来向从redis传输数据。但是这可能会增加一些同步的延迟，大概会达到40毫秒左右。如果你关闭了TCP_NODELAY，那么数据同步的延迟时间会降低，但是会消耗更多的带宽。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">repl-<span class="keyword">disable</span>-tcp-nodelay <span class="keyword">no</span></span><br></pre></td></tr></table></figure>
<p>我们还可以设置同步队列长度。队列长度（backlog)是主redis中的一个缓冲区，在与从redis断开连接期间，主redis会用这个缓冲区来缓存应该发给从redis的数据。这样的话，当从redis重新连接上之后，就不必重新全量同步数据，只需要同步这部分增量数据即可。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">repl-backlog-size <span class="number">1</span>mb</span><br></pre></td></tr></table></figure>
<p>如果主redis等了一段时间之后，还是无法连接到从redis，那么缓冲队列中的数据将被清理掉。我们可以设置主redis要等待的时间长度。如果设置为0，则表示永远不清理。默认是1个小时。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">repl-backlog-ttl <span class="number">3600</span></span><br></pre></td></tr></table></figure>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>我们可以要求redis客户端在向redis-server发送请求之前，先进行密码验证。当你的redis-server处于一个不太可信的网络环境中时，相信你会用上这个功能。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">requirepass ranger</span></span><br></pre></td></tr></table></figure>
<p>redis允许我们对redis指令进行更名，比如将一些比较危险的命令改个名字，避免被误执行。比如可以把CONFIG命令改成一个很复杂的名字，这样可以避免外部的调用，同时还可以满足内部调用的需要</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">rename-command<span class="built_in"> CONFIG </span>b840fc02d524045429941cc15f59e41cb7be6c89</span><br></pre></td></tr></table></figure>
<p>我们甚至可以禁用掉CONFIG命令，那就是把CONFIG的名字改成一个空字符串：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">rename-command<span class="built_in"> CONFIG </span><span class="string">""</span></span><br></pre></td></tr></table></figure>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>我们可以设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">maxclients <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>我们甚至可以设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p>
<p>如果redis无法根据移除规则来移除内存中的数据，或者我们设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">maxmemory <span class="tag">&lt;<span class="name">bytes</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于内存移除规则来说，redis提供了多达6种的移除规则</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">maxmemory-<span class="keyword">policy</span> <span class="keyword">volatile</span>-lru</span><br></pre></td></tr></table></figure>
<p>LRU算法和最小TTL算法都并非是精确的算法，而是估算值。所以你可以设置样本的大小。假如redis默认会检查三个key并选择其中LRU的那个，那么你可以改变这个key样本的数量。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">maxmemory-samples <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h1 id="追加模式"><a href="#追加模式" class="headerlink" title="追加模式"></a>追加模式</h1><p>我们建议大家，AOF机制和RDB机制可以同时使用，不会有任何冲突</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<p>我们还可以设置aof文件的名称：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">appendfilename</span> <span class="string">"appendonly.aof"</span></span><br></pre></td></tr></table></figure>
<p>fsync()调用，用来告诉操作系统立即将缓存的指令写入磁盘。一些操作系统会“立即”进行，而另外一些操作系统则会“尽快”进行。</p>
<p>redis支持三种不同的模式：</p>
<p>1.no：不调用fsync()。而是让操作系统自行决定sync的时间。这种模式下，redis的性能会最快。<br>2.always：在每次写请求后都调用fsync()。这种模式下，redis会相对较慢，但数据最安全。<br>3.everysec：每秒钟调用一次fsync()。这是性能和安全的折衷。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">appendfsync everysec</span></span><br></pre></td></tr></table></figure>
<p>我们允许redis自动重写aof。当aof增长到一定规模时，redis会隐式调用BGREWRITEAOF来重写log文件，以缩减文件体积。</p>
<p>redis是这样工作的：redis会记录上次重写时的aof大小。假如redis自启动至今还没有进行过重写，那么启动时aof文件的大小会被作为基准值。这个基准值会和当前的aof大小进行比较。如果当前aof大小超出所设置的增长比例，则会触发重写。另外，你还需要设置一个最小大小，是为了防止在aof很小时就触发重写。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="built_in">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure>
<h1 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h1><p>lua脚本的最大运行时间是需要被严格限制的，要注意单位是毫秒：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">lua-<span class="built_in">time</span>-<span class="built_in">limit</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<h1 id="慢日志"><a href="#慢日志" class="headerlink" title="慢日志"></a>慢日志</h1><p>redis慢日志是指一个系统进行日志查询超过了指定的时长。这个时长不包括IO操作，比如与客户端的交互、发送响应内容等，而仅包括实际执行查询命令的时间。</p>
<p>针对慢日志，你可以设置两个参数，一个是执行时长，单位是微秒，另一个是慢日志的长度。当一个新的命令被写入日志时，最老的一条会从命令日志队列中被移除。</p>
<p>单位是微秒，即1000000表示一秒。负数则会禁用慢日志功能，而0则表示强制记录每一个命令。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">slowlog-<span class="built_in">log</span>-slower-than <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>慢日志最大长度，可以随便填写数值，没有上限，但要注意它会消耗内存。你可以使用SLOWLOG RESET来重设这个值。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">slowlog-<span class="built_in">max</span>-<span class="built_in">len</span> <span class="number">128</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库，redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot入门</title>
    <url>/2019/01/01/ckybpqxgs0011d2nhbggi3d56/</url>
    <content><![CDATA[<h2 id="了解SpringBoot"><a href="#了解SpringBoot" class="headerlink" title="了解SpringBoot"></a>了解SpringBoot</h2><h3 id="为什么学习SpringBoot"><a href="#为什么学习SpringBoot" class="headerlink" title="为什么学习SpringBoot"></a>为什么学习SpringBoot</h3><p>java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点：</p>
<ul>
<li>复杂的配置，<br>项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。</li>
<li>一个是混乱的依赖管理。<br>项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。</li>
</ul>
<a id="more"></a>
<h3 id="SpringBoot的特点"><a href="#SpringBoot的特点" class="headerlink" title="SpringBoot的特点"></a>SpringBoot的特点</h3><p>Spring Boot 主要目标是：</p>
<ul>
<li>为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验</li>
<li>开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。</li>
<li>提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等</li>
<li>绝对没有代码生成，也无需 XML 配置。</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="建立Maven工程"><a href="#建立Maven工程" class="headerlink" title="建立Maven工程"></a>建立Maven工程</h3><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，<br>我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！</p>
<h4 id="添加父工程坐标"><a href="#添加父工程坐标" class="headerlink" title="添加父工程坐标"></a>添加父工程坐标</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="添加Web启动器"><a href="#添加Web启动器" class="headerlink" title="添加Web启动器"></a>添加Web启动器</h4><p>为了让SpringBoot帮我们完成各种自动配置，<br>我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="管理JDK版本"><a href="#管理JDK版本" class="headerlink" title="管理JDK版本"></a>管理JDK版本</h3><p>默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">ranger</span>.<span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(org.ranger.Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加Controller"><a href="#添加Controller" class="headerlink" title="添加Controller"></a>添加Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,spring boot~!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h2><h3 id="回顾历史"><a href="#回顾历史" class="headerlink" title="回顾历史"></a>回顾历史</h3><p>在以前我们配置一个bean该怎么做呢？</p>
<p>在xml配置文件中添加标签,例如配置数据库连接池<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用Java配置"><a href="#使用Java配置" class="headerlink" title="使用Java配置"></a>使用Java配置</h3><p>Java配置主要是使用Java注解和类</p>
<ul>
<li><code>@Configuration</code>:声明一个类作为配置类，代替xml文件</li>
<li><code>@Bean</code>:声明在方法上，根据方法的返回值加入Bean容器，代替<code>&lt;bean/&gt;</code>标签</li>
<li><code>@Value</code>:属性注入</li>
<li><code>PropertySource</code>:指定外部属性文件</li>
</ul>
<p>我们使用Java配置来配置数据库连接池,首先引入连接池依赖<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>创建配置文件类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"jdbc.properties"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String url1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(url1);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SpringBoot的属性注入"><a href="#SpringBoot的属性注入" class="headerlink" title="SpringBoot的属性注入"></a>SpringBoot的属性注入</h3><p>上面我们使用了<code>@Value</code>注解来注入属性，这种方式可行但不能注入复杂的类型</p>
<p>SpringBoot中提供了另外一种属性注入的方式，这种方式既可以注入基本数据类型也可注入复杂数据类型</p>
<p>使用<code>@ConfigurationProperties(prefix=&quot;jdbc&quot;)</code></p>
<p><code>application.yml</code>中配置相应的属性值：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/leyou</span></span><br><span class="line">  <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">cyp</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">cyp</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jdbc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDriverClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> driverClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriverClassName</span><span class="params">(String driverClassName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driverClassName = driverClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象</p>
<p>可以使用以下方式注入<code>JDBCProperties对象</code></p>
<ul>
<li>@Autowired注入  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcProperties prop;</span><br></pre></td></tr></table></figure></li>
<li>构造函数注入  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> JdbcProperties prop;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcConfig</span><span class="params">(Jdbcproperties prop)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.prop = prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>声明有@Bean的方法参数注入  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Datasource <span class="title">dataSource</span><span class="params">(JdbcProperties prop)</span></span>&#123;</span><br><span class="line">   <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
本例中，我们采用第三种方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(JDBCProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JDBCConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(JDBCProperties jdbc)</span></span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(jdbc.getUrl());</span><br><span class="line">        System.out.println(jdbc.getUrl());</span><br><span class="line">        dataSource.setDriverClassName(jdbc.getDriverClassName());</span><br><span class="line">        dataSource.setUsername(jdbc.getUsername());</span><br><span class="line">        dataSource.setPassword(jdbc.getPassword());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><p>使用了 SpringBoot之后，以前很多繁琐的配置文件都不需要我们自己写了，这是怎么做到的呢，这一切都依赖于SpringBoot的自动配置</p>
<p>SpringBoot应用是从main方法开始的，main方法所在的类有一个<code>@SpringBootApplication</code>注解。</p>
<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>查看该注解的源码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">		@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure></p>
<p>这里重点的注解有3个：</p>
<ul>
<li>@SpringBootConfiguration</li>
<li>@EnableAutoConfiguration</li>
<li>ComponentScan</li>
</ul>
<h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>查看这个注解的源码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：<br>这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。<br>而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。</p>
<h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。</p>
<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configures component scanning directives for use with @&#123;<span class="doctag">@link</span> Configuration&#125; classes.</span></span><br><span class="line"><span class="comment"> * Provides support parallel with Spring XML's &#123;<span class="doctag">@code</span> &lt;context:component-scan&gt;&#125; element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Either &#123;<span class="doctag">@link</span> #basePackageClasses&#125; or &#123;<span class="doctag">@link</span> #basePackages&#125; (or its alias</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #value&#125;) may be specified to define specific packages to scan. If specific</span></span><br><span class="line"><span class="comment"> * packages are not defined, scanning will occur from the package of the</span></span><br><span class="line"><span class="comment"> * class that declares this annotation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that the &#123;<span class="doctag">@code</span> &lt;context:component-scan&gt;&#125; element has an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> annotation-config&#125; attribute; however, this annotation does not. This is because</span></span><br><span class="line"><span class="comment"> * in almost all cases when using &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>&#125;, default annotation config</span></span><br><span class="line"><span class="comment"> * processing (e.g. processing &#123;<span class="doctag">@code</span> <span class="doctag">@Autowired</span>&#125; and friends) is assumed. Furthermore,</span></span><br><span class="line"><span class="comment"> * when using &#123;<span class="doctag">@link</span> AnnotationConfigApplicationContext&#125;, annotation config processors are</span></span><br><span class="line"><span class="comment"> * always registered, meaning that any attempt to disable them at the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>&#125; level would be ignored.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;See &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125;'s Javadoc for usage examples.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam Brannen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Configuration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(ComponentScans<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">ComponentScan</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>大概的意思：</p>
<blockquote>
<p>配置组件扫描的指令。提供了类似与<a href="context:component-scan">context:component-scan</a>标签的作用<br>通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包</p>
</blockquote>
<p>而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。</p>
<h3 id="默认配置原理"><a href="#默认配置原理" class="headerlink" title="默认配置原理"></a>默认配置原理</h3><p>通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了：</p>
<ul>
<li>这些默认配置是在哪里定义的呢？</li>
<li>为何依赖引入就会触发配置呢？</li>
</ul>
<p>其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类<br><img src="/2019/01/01/ckybpqxgs0011d2nhbggi3d56/SpringBoot自动配置类.png" alt=""></p>
<p>这里面几乎涵盖了所有的主流框架</p>
<p>SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个：</p>
<ul>
<li>你引入了相关依赖</li>
<li>你自己没有配置</li>
</ul>
<p>1）启动器</p>
<p>所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。</p>
<p>2）全局配置</p>
<p>另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。</p>
<h2 id="实践-加密数据库密码"><a href="#实践-加密数据库密码" class="headerlink" title="实践:加密数据库密码"></a>实践:加密数据库密码</h2><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ulisesbocchio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jasypt-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置加密密钥<br><code>jasypt.encryptor.password=ranger</code></p>
<p>获取加密后的数据<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= Application<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">EncryptTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringEncryptor encryptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//加密username</span></span><br><span class="line">        String username = encryptor.encrypt(<span class="string">"cyp"</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">//加密password</span></span><br><span class="line">        String password = encryptor.encrypt(<span class="string">"cyp"</span>);</span><br><span class="line">        System.out.println(password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>配置文件中配置</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity初探</title>
    <url>/2019/07/02/ckybpqxgt0014d2nh5dz5be19/</url>
    <content><![CDATA[<h2 id="SpringSecurity，为什么？"><a href="#SpringSecurity，为什么？" class="headerlink" title="SpringSecurity，为什么？"></a>SpringSecurity，为什么？</h2><p>在权限管理框架中，有两座大山，Shiro和SpringSecurity,后者具有天然具有Spring家族的支撑，提供了一系列完整的功能，Shiro作为一个简单的框架，也可以满足大多数场景下的需求。之前简单使用过Shiro，知道它是通过一些列的Filter来做认证的鉴权。这次打算看一下SpringSecurity的使用，听过这个框架比较复杂，在网上看的一些文字教程也比较晕，还是自己来探究一下才能有更好的理解<br><a id="more"></a></p>
<h2 id="Spring-Security介绍"><a href="#Spring-Security介绍" class="headerlink" title="Spring Security介绍"></a>Spring Security介绍</h2><ul>
<li>开源</li>
<li>提供企业级的安全认证和授权</li>
</ul>
<p>Spring安全拦截器</p>
<ul>
<li><p>认证管理器</p>
<ul>
<li><p>认证模式</p>
<ul>
<li><p>Basic </p>
<p>HTTP 1.0中使用的认证方法，使用用户名和密码Base64编码的方式</p>
<p>浏览器弹出对话框，用户输入用户名和密码，加入头部</p>
<p>无状态</p>
<p>安全性不足</p>
</li>
<li><p>Digest</p>
<p>解决安全性问题</p>
<p>浏览器对用户名和密码请求方法，URL等进行MD5运算，发送到服务器</p>
<p>服务器获取到用户名密码，请求方法，URL等MD5运算，查看是否相等</p>
<p>安全性问题依然存在</p>
</li>
<li><p>X.509</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>访问决策管理器</p>
</li>
<li><p>运行身份管理器</p>
</li>
</ul>
<h3 id="常用权限拦截器"><a href="#常用权限拦截器" class="headerlink" title="常用权限拦截器"></a>常用权限拦截器</h3><p>Spring-Security拦截器链流程图</p>
<p><img src="/2019/07/02/ckybpqxgt0014d2nh5dz5be19/Spring-Security认证Filter.jpg" alt=""></p>
<p>介绍几个常用的Filter</p>
<ol>
<li><p>SecurityContextPersistenceFilter</p>
<p>基于ThreadLocal</p>
</li>
<li><p>LogoutFilter</p>
<p>发送注销请求时，清空用户的session,cookie，重定向</p>
</li>
<li><p>AbstractAuthenticationProcessingFilter</p>
<p>用户登录的请求</p>
</li>
<li><p>DefaultLoginPageGeneratingFilter</p>
<p>生成登录页面</p>
</li>
<li><p>BasicAuthencationFilter</p>
</li>
<li><p>SecurityContextHolderAwareRequestFilter</p>
<p>包装，提供额外的数据</p>
</li>
<li><p>RememberMeAuthemticationFilter</p>
<p>提供RememberMe功能，当cookie中存在rememberme时，登录成功后生成唯一cookie</p>
</li>
<li><p>ExceptionTranlationFilter</p>
<p>请求到对应的页面，响应异常</p>
<p>ExceptionTranslationFilter异常处理过滤器,该过滤器用来处理在系统认证授权过程中抛出的异常（也就是下一个过滤器<code>FilterSecurityInterceptor</code>）,主要是 处理  <code>AuthenticationException</code> 和<code>AccessDeniedException</code></p>
</li>
<li><p>SessionManagerFilter</p>
</li>
<li><p>FilterSecurityInterceptor（授权）</p>
<p>用户没有登录，抛出未登录异常</p>
<p>用户登录，但是没有权限访问该资源，抛出拒绝访问的异常</p>
<p>用户登录，有权限，则放行</p>
</li>
</ol>
<pre><code>此过滤器为认证授权过滤器链中最后一个过滤器，该过滤器之后就是请求真正的 服务
</code></pre><h3 id="Filter如何执行"><a href="#Filter如何执行" class="headerlink" title="Filter如何执行"></a>Filter如何执行</h3><blockquote>
<p>FilterChainProxy会按照顺序调用一组Filter，完成授权验证</p>
</blockquote>
<p>请求首先经过Servlet Filter链，这里面包含6个Filter</p>
<p><img src="/2019/07/02/ckybpqxgt0014d2nh5dz5be19/springboot mvc 启动6大Filter.png" alt=""></p>
<p>可以看到如下的一个Filter</p>
<p><code>ApplicationFilterConfig[name=springSecurityFilterChain, filterClass=org.springframework.boot.web.servlet.DelegatingFilterProxyRegistrationBean$1]</code></p>
<p>这个就是Spring Security Filter的入口，它的类型是<code>DelegationFilterProxy</code></p>
<p>那么，这个DelegationFilterProxy到底执行了什么样的操作呢？可以简单看一下源码</p>
<p>重点看一下部分的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingFilterProxy</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类中的属性</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> String contextAttribute;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> WebApplicationContext webApplicationContext;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> String targetBeanName;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> targetFilterLifecycle = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重点在于这个属性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Filter delegate;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object delegateMonitor = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Lazily initialize the delegate if necessary.</span></span><br><span class="line">		Filter delegateToUse = <span class="keyword">this</span>.delegate;</span><br><span class="line">		<span class="keyword">if</span> (delegateToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.delegateMonitor) &#123;</span><br><span class="line">				delegateToUse = <span class="keyword">this</span>.delegate;</span><br><span class="line">				<span class="keyword">if</span> (delegateToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">					WebApplicationContext wac = findWebApplicationContext();</span><br><span class="line">					<span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No WebApplicationContext found: "</span> +</span><br><span class="line">								<span class="string">"no ContextLoaderListener or DispatcherServlet registered?"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					delegateToUse = initDelegate(wac);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">this</span>.delegate = delegateToUse;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Let the delegate perform the actual doFilter operation.</span></span><br><span class="line">		invokeDelegate(delegateToUse, request, response, filterChain);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initialize the Filter delegate, defined as bean the given Spring</span></span><br><span class="line"><span class="comment">	 * application context.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation fetches the bean from the application context</span></span><br><span class="line"><span class="comment">	 * and calls the standard &#123;<span class="doctag">@code</span> Filter.init&#125; method on it, passing</span></span><br><span class="line"><span class="comment">	 * in the FilterConfig of this Filter proxy.</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> wac the root application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the initialized delegate Filter</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ServletException if thrown by the Filter</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Filter <span class="title">initDelegate</span><span class="params">(WebApplicationContext wac)</span> <span class="keyword">throws</span> ServletException 	</span>&#123;</span><br><span class="line">		String targetBeanName = getTargetBeanName();</span><br><span class="line">		Assert.state(targetBeanName != <span class="keyword">null</span>, <span class="string">"No target bean name set"</span>);</span><br><span class="line">		Filter delegate = wac.getBean(targetBeanName, Filter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (isTargetFilterLifecycle()) &#123;</span><br><span class="line">			delegate.init(getFilterConfig());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> delegate;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用delegate的doFilter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		delegate.doFilter(request, response, filterChain);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据以上代码的注释我们可以看出大概的执行流程</p>
<p>那类中的Filter delegate是什么呢？断点调式运行可以找到以下东西</p>
<p><img src="/2019/07/02/ckybpqxgt0014d2nh5dz5be19/Spring-Security FilterProxy.png" alt=""></p>
<p>这是Spring Security 提供的一个FilterChainProxy,关注其中的关键源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChainProxy</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 包含一组SecurityFilterChain</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">			FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> clearContext = request.getAttribute(FILTER_APPLIED) == <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (clearContext) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">				doFilterInternal(request, response, chain);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				SecurityContextHolder.clearContext();</span><br><span class="line">				request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			doFilterInternal(request, response, chain);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">			FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">		FirewalledRequest fwRequest = firewall</span><br><span class="line">				.getFirewalledRequest((HttpServletRequest) request);</span><br><span class="line">		HttpServletResponse fwResponse = firewall</span><br><span class="line">				.getFirewalledResponse((HttpServletResponse) response);</span><br><span class="line">		</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据请求获取匹配的一组Filter</span></span><br><span class="line">        <span class="comment">// 这里返回的Filter就是上述的那些AuthenticationFilter,比如UsernamePasswordAuthenticationFilter</span></span><br><span class="line">		List&lt;Filter&gt; filters = getFilters(fwRequest);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (filters == <span class="keyword">null</span> || filters.size() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(UrlUtils.buildRequestUrl(fwRequest)</span><br><span class="line">						+ (filters == <span class="keyword">null</span> ? <span class="string">" has no matching filters"</span></span><br><span class="line">								: <span class="string">" has an empty filter list"</span>));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fwRequest.reset();</span><br><span class="line"></span><br><span class="line">			chain.doFilter(fwRequest, fwResponse);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		VirtualFilterChain vfc = <span class="keyword">new</span> VirtualFilterChain(fwRequest, chain, filters);</span><br><span class="line">		vfc.doFilter(fwRequest, fwResponse);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns the first filter chain matching the supplied URL.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request the request to match</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> an ordered array of Filters defining the filter chain</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> List&lt;Filter&gt; <span class="title">getFilters</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;</span><br><span class="line">			<span class="keyword">if</span> (chain.matches(request)) &#123;</span><br><span class="line">				<span class="keyword">return</span> chain.getFilters();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，我们可以总结出如下的流程图：</p>
<p><img src="/2019/07/02/ckybpqxgt0014d2nh5dz5be19/FilterChainProxy流程.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>认证，授权，SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>动手写一个LRU缓存</title>
    <url>/2018/11/27/ckybpqxgu0015d2nh2hny6xkr/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>LRU 是 <code>Least Recently Used</code> 的简写，字面意思则是<code>最近最少使用</code>。</p>
<p>通常用于缓存的淘汰策略实现，由于缓存的内存非常宝贵，所以需要根据某种规则来剔除数据保证内存不被占满。</p>
<p>在<code>redis</code>的数据淘汰策略中就包含<code>LRU淘汰算法</code></p>
<p>如何实现一个完整的<code>LRU缓</code>存呢？这个缓存要满足：</p>
<ul>
<li>这个缓存要记录使用的顺序</li>
<li>随着缓存的使用变化，要能更新缓存的顺序</li>
</ul>
<a id="more"></a>
<p>基于这种特点，可以使用一个常用的数据结构：<code>链表</code></p>
<ul>
<li>每次加入新的缓存时都添加到链表的<code>头节点</code></li>
<li>当缓存再次被使用时移动缓存到<code>头节点</code></li>
<li>当添加的缓存超过能够缓存的最大时，删除链表<code>尾节点</code>的元素</li>
</ul>
<h1 id="单链表和双向链表的选择"><a href="#单链表和双向链表的选择" class="headerlink" title="单链表和双向链表的选择"></a>单链表和双向链表的选择</h1><p>单链表的方向只有一个，节点中有一个<code>next</code>指针指向后继节点。而双链表有两个指针，可以支持两个方向，每个节点不止有一个<code>next</code>指针，还有一个<code>pre</code>v指针指向前驱节点</p>
<p>双向链表需要额外的两个空间来存放前驱节点的指针<code>prev</code>和后继节点指针<code>next</code>,所以，存储相同大小的数据，双向链表需要更多的空间。虽然相比单向链表，双向链表的每个节点多个一个指针空间，但是这样的结构带来了更多的灵活性，在某些场景下非常适合使用这样的数据结构。删除和添加节点操作，双向链表的时间复杂度为O(1)</p>
<p>在单向链表中，删除和添加节点的时间复杂度已经是O(1)了，双向链表还能比单向链表更加高效吗？</p>
<p>先来看看<code>删除操作</code>：</p>
<p>在删除操作中有两种情况：</p>
<ul>
<li>删除给定值的节点</li>
<li>删除给定指针的节点</li>
</ul>
<p>对于第一种情况，无论是删除给定值或者是给定的指针都需要从链表头开始依此遍历，直到找到所要删除的值</p>
<p>尽管删除这个操作的时间复杂度为O(1)，但是删除的时间消耗主要是遍历节点，对应的时间复杂度为O(n),所以总的时间复杂度为O(n)。</p>
<p>对于第二种情况，已经给定了要删除的节点，如果使用单向链表，还得从链表头部开始遍历，直到找到待删除节点的前驱节点。但是对于双向链表来所，这就很有优势了，双向链表的待删除节点种包含了前驱节点，删除操作只需要O(1)的时间复杂度</p>
<p>同理对于<code>添加操作：</code></p>
<p>我们如果想要在指定的节点前面或者后面插入一个元素，双向了链表就有很大的优势，他可以在O(1)的时间复杂度搞定，而单向链表还需要从头遍历。</p>
<p>所以，虽然双向链表比单向链表需要更多的存储空间，但是双向链表的应用更加广泛，JDK种LinkedHashMap这种数据结构就使用了双向链表</p>
<h1 id="如何实现LRU缓存"><a href="#如何实现LRU缓存" class="headerlink" title="如何实现LRU缓存"></a>如何实现LRU缓存</h1><p>##　单链表实现</p>
<p>下面我们基于单链表给出简单的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ranger.lru;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ranger</span></span><br><span class="line"><span class="comment"> * LRU缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义链表节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> ranger</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        Node&lt;K, V&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 缓存最大值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当前缓存数量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 缓存链表头节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Node&lt;K,V&gt; head;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 缓存链表尾节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Node&lt;K,V&gt; tail;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义带参构造函数,构造一个为空的双向链表</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> capacity  缓存最大容量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LRUMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">		head = <span class="keyword">null</span>;</span><br><span class="line">		tail = <span class="keyword">null</span>;</span><br><span class="line">		size = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 无参构造函数，初始化容量为16</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LRUMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向双向链表中添加节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span> </span>&#123;</span><br><span class="line">		addNode(key,value);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据key获取缓存中的Value</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">		Node&lt;K,V&gt; retNode = getNode(key);</span><br><span class="line">		<span class="keyword">if</span>(retNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 存在，插入头部</span></span><br><span class="line">			moveToHead(retNode);</span><br><span class="line">			<span class="keyword">return</span> retNode.value;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不存在</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 移动给定的节点到头节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果待移动节点是最后一个节点</span></span><br><span class="line">		<span class="keyword">if</span>(node == tail) &#123;</span><br><span class="line">			Node prev = head;</span><br><span class="line">			<span class="keyword">while</span>(prev.next != <span class="keyword">null</span> &amp;&amp; prev.next != node) &#123;</span><br><span class="line">				prev = prev.next;</span><br><span class="line">			&#125;</span><br><span class="line">			tail = prev;</span><br><span class="line">			node.next = head;</span><br><span class="line">			head = node;</span><br><span class="line">			prev.next = <span class="keyword">null</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(node == head)&#123;   <span class="comment">// 如果是头节点</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			Node prev = head;</span><br><span class="line">			<span class="keyword">while</span>(prev.next != <span class="keyword">null</span> &amp;&amp; prev.next != node) &#123;</span><br><span class="line">				prev = prev.next;</span><br><span class="line">			&#125;</span><br><span class="line">			prev.next = node.next;</span><br><span class="line">			node.next = head;</span><br><span class="line">			head = node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取给定key的节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"list is empty,cannot get node from it"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Node&lt;K,V&gt; cur = head;</span><br><span class="line">		<span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(cur.key.equals(key)) &#123;</span><br><span class="line">				<span class="keyword">return</span> cur;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加到头节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(K key,V value)</span> </span>&#123;</span><br><span class="line">		Node&lt;K,V&gt; node = <span class="keyword">new</span> Node&lt;&gt;(key,value);</span><br><span class="line">		<span class="comment">// 如果容量满了，删除最后一个节点</span></span><br><span class="line">		<span class="keyword">if</span>(size == capacity) &#123;</span><br><span class="line">			delTail();</span><br><span class="line">		&#125;</span><br><span class="line">		addHead(node);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 删除最后一个节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"list is empty,cannot del from it"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 只有一个元素</span></span><br><span class="line">		<span class="keyword">if</span>(tail == head) &#123;</span><br><span class="line">			tail = <span class="keyword">null</span>;</span><br><span class="line">			head = tail;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			Node&lt;K,V&gt; prev = head;</span><br><span class="line">			<span class="keyword">while</span>(prev.next != <span class="keyword">null</span> &amp;&amp; prev.next != tail) &#123;</span><br><span class="line">				prev = prev.next;</span><br><span class="line">			&#125;</span><br><span class="line">			prev.next = <span class="keyword">null</span>;</span><br><span class="line">			tail = prev;</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		size--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 链表是否为空</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加节点到头头部</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果链表为空</span></span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			head = node;</span><br><span class="line">			tail = head;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			node.next = head;</span><br><span class="line">			head = node;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		size ++;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		Node&lt;K,V&gt; cur = head;</span><br><span class="line">		<span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">			sb.append(cur.key)</span><br><span class="line">			.append(<span class="string">":"</span>)</span><br><span class="line">			.append(cur.value);</span><br><span class="line">			<span class="keyword">if</span>(cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">				sb.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 测试</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		LRUMap&lt;String,String&gt; lruMap = <span class="keyword">new</span> LRUMap(<span class="number">3</span>) ;</span><br><span class="line">        lruMap.put(<span class="string">"1"</span>,<span class="string">"tom"</span>) ;</span><br><span class="line">        lruMap.put(<span class="string">"2"</span>,<span class="string">"lisa"</span>) ;</span><br><span class="line">        lruMap.put(<span class="string">"3"</span>,<span class="string">"john"</span>) ;</span><br><span class="line">        System.out.println(lruMap.toString());</span><br><span class="line">        lruMap.put(<span class="string">"4"</span>,<span class="string">"july"</span>) ;</span><br><span class="line">        System.out.println(lruMap.toString());</span><br><span class="line">        lruMap.put(<span class="string">"5"</span>,<span class="string">"jack"</span>) ;</span><br><span class="line">        System.out.println(lruMap.toString());</span><br><span class="line">        String value = lruMap.get(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(lruMap.toString());</span><br><span class="line">        System.out.println(<span class="string">"the value is: "</span>+value);</span><br><span class="line">        String value1 = lruMap.get(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(value1);</span><br><span class="line">        System.out.println(lruMap.toString());</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">3</span>:john-&gt;<span class="number">2</span>:lisa-&gt;<span class="number">1</span>:tom</span><br><span class="line"><span class="number">4</span>:july-&gt;<span class="number">3</span>:john-&gt;<span class="number">2</span>:lisa</span><br><span class="line"><span class="number">5</span>:jack-&gt;<span class="number">4</span>:july-&gt;<span class="number">3</span>:john</span><br><span class="line"><span class="number">3</span>:john-&gt;<span class="number">5</span>:jack-&gt;<span class="number">4</span>:july</span><br><span class="line">the value is: john</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="number">3</span>:john-&gt;<span class="number">5</span>:jack-&gt;<span class="number">4</span>:july</span><br></pre></td></tr></table></figure>
<h2 id="LinkedHashMap实现"><a href="#LinkedHashMap实现" class="headerlink" title="LinkedHashMap实现"></a>LinkedHashMap实现</h2><p>了解<code>LinkedHashMap</code>的都知道，它是基于链表实现，其中还有一个 <code>accessOrder</code> 成员变量，默认是 <code>false</code>，默认按照插入顺序排序，为 <code>true</code> 时按照访问顺序排序，也可以调用 构造函数传入<code>accessOrder</code></p>
<p><code>LinkedHashMap</code> 的排序方式有两种：</p>
<ul>
<li>根据写入顺序排序。</li>
<li>根据访问顺序排序。</li>
</ul>
<p>其中根据访问顺序排序时，每次 <code>get</code> 都会将访问的值移动到链表末尾，这样重复操作就能的到一个按照访问顺序排序的链表</p>
<p>我们可以重写<code>LinkedHashMap</code>中的<code>removeEldestEntry</code>方法来决定在添加节点的时候是否需要删除最久未使用的节点</p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRULinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 缓存map</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> LinkedHashMap&lt;K,V&gt; cacheMap;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当前缓存数量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造一个cacheMap，并设置可以缓存的数量</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LRULinkedHashMap</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.size = size;</span><br><span class="line">		</span><br><span class="line">		cacheMap = <span class="keyword">new</span> LinkedHashMap&lt;K,V&gt;(<span class="number">16</span>,<span class="number">0.75F</span>,<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="comment">// 重写方法，判断是否删除最久没使用的节点</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (size + <span class="number">1</span> == cacheMap.size())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加缓存</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        cacheMap.put(key,value) ;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取缓存</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cacheMap.get(key) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    	Set&lt;Entry&lt;K, V&gt;&gt; entrySet = cacheMap.entrySet();</span><br><span class="line">    	<span class="keyword">for</span> (Entry&lt;K,V&gt; entry : entrySet) &#123;</span><br><span class="line">    		sb.append(entry.getKey())</span><br><span class="line">    		.append(<span class="string">":"</span>)</span><br><span class="line">    		.append(entry.getValue())</span><br><span class="line">    		.append(<span class="string">"&lt;-"</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	LRULinkedHashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> LRULinkedHashMap(<span class="number">3</span>) ;</span><br><span class="line">        map.put(<span class="string">"1"</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">"2"</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">"3"</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.put(<span class="string">"4"</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LRU</tag>
        <tag>算法，缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>开启spring boot</title>
    <url>/2019/07/22/ckybpqxgv0018d2nhcuf1f93v/</url>
    <content><![CDATA[<p>Spring Boot开发的目的是为了简化Spring应用的开发，使用Spring Boot可以零配置开启一个Spring应用。这得益于Spring Boot中的自动配置组件，如果开发者觉得默认的配置文件不满足要求，<br>可以自己配置一个<code>properties</code>文件或者<code>yml</code>文件,配置文件中填写需要覆盖的配置，来达到定制化的效果<br><a id="more"></a></p>
<h3 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h3><p>这里使用IDEA工具来生成一个Spring Boot的项目.<br>IDEA创建新项目，选择图片中红框中的内容<br><img src="/2019/07/22/ckybpqxgv0018d2nhcuf1f93v/Spring%20Boot项目搭建一.png" alt=""></p>
<p>点击下一步，填写包名和项目名称等相关信息<br><img src="/2019/07/22/ckybpqxgv0018d2nhcuf1f93v/Spring%20Boot项目搭建二.png" alt=""></p>
<p>下一步后选择需要添加的依赖，这里我们暂时还不需要添加依赖，就不勾选任何依赖<br><img src="/2019/07/22/ckybpqxgv0018d2nhcuf1f93v/Spring%20Boot项目搭建三.png" alt=""></p>
<p>然后选择项目文件的路径,选择finish就可以创建一个简单的Spring Boot应用程序<br><img src="/2019/07/22/ckybpqxgv0018d2nhcuf1f93v/Spring%20Boot项目搭建四.png" alt=""></p>
<h3 id="运行演示"><a href="#运行演示" class="headerlink" title="运行演示"></a>运行演示</h3><p>运行启动类的main方法，就可以启动刚刚创建的Spring Boot应用<br><img src="/2019/07/22/ckybpqxgv0018d2nhcuf1f93v/Spring%20Boot项目搭建启动类.png" alt=""></p>
<p>启动过后，应用会在控制台打印出启动的日志信息<br><img src="/2019/07/22/ckybpqxgv0018d2nhcuf1f93v/Spring%20Boot项目搭建启动日志.png" alt=""></p>
<p>如果没有异常信息，那么这个最简单的Spring Boot应用就成功搭建并运行了</p>
<h3 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h3><p>Spring Boot创建的应用可以有两个运行方式，一种是将整个项目打包成Jar包直接运行，这是因为Spring Boot中集成了tomcat容器。<br>另外一张方式就是把项目打包成war包，然后放入tomcat服务器中，运行tomcat来访问应用</p>
<p>简单起见，在这里我们先使用第一中介绍的使用Jar包运行的方式，另外一种方式我们会在后面介绍怎么做</p>
<p>先修改项目的pom文件中的maven打包方式为jar<br><img src="/2019/07/22/ckybpqxgv0018d2nhcuf1f93v/maven打包成jar的pom文件修改.png" alt=""></p>
<p>然后可以看到生成的jar文件<br><img src="/2019/07/22/ckybpqxgv0018d2nhcuf1f93v/生成的Jar包.png" alt=""></p>
<p>我们可以直接在命令行中使用<code></code>java -jar `来运行打包的jar文件<br><img src="/2019/07/22/ckybpqxgv0018d2nhcuf1f93v/命令行运行springboot的jar文件.png" alt=""></p>
<p>可以看到应用打印出的启动日志</p>
<h3 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h3><p>神奇的发现我们什么都没有配置就能够开启一个Spring的应用，这是怎么做到的呢？先从<code>pom.xml</code>分析导入了什么依赖<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-start<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从pom文件中我们可以看到项目导入了几个依赖，分别是web，test依赖，一个用于web开发支持，一个用于测试支持</p>
<p>spring-boot-starter-parent指定了当前项目为一个Spring Boot项目，它提供了诸多的默认Maven依赖，具体可查看目录repository\org\springframework\boot\spring-boot-dependencies\1.5.9.RELEASE下的spring-boot-dependencies-1.5.9.RELEASE.pom文件，这里仅截取一小部分：<br>这里定义了很多依赖的版本<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-security.version</span>&gt;</span>4.2.3.RELEASE<span class="tag">&lt;/<span class="name">spring-security.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-security-jwt.version</span>&gt;</span>1.0.8.RELEASE<span class="tag">&lt;/<span class="name">spring-security-jwt.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-security-oauth.version</span>&gt;</span>2.0.14.RELEASE<span class="tag">&lt;/<span class="name">spring-security-oauth.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-session.version</span>&gt;</span>1.3.1.RELEASE<span class="tag">&lt;/<span class="name">spring-session.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-social.version</span>&gt;</span>1.1.4.RELEASE<span class="tag">&lt;/<span class="name">spring-social.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-social-facebook.version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">spring-social-facebook.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-social-linkedin.version</span>&gt;</span>1.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring-social-linkedin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-social-twitter.version</span>&gt;</span>1.1.2.RELEASE<span class="tag">&lt;/<span class="name">spring-social-twitter.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-ws.version</span>&gt;</span>2.4.2.RELEASE<span class="tag">&lt;/<span class="name">spring-ws.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sqlite-jdbc.version</span>&gt;</span>3.15.1<span class="tag">&lt;/<span class="name">sqlite-jdbc.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">statsd-client.version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">statsd-client.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sun-mail.version</span>&gt;</span>$&#123;javax-mail.version&#125;<span class="tag">&lt;/<span class="name">sun-mail.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thymeleaf-extras-springsecurity4.version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf-extras-springsecurity4.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thymeleaf-extras-conditionalcomments.version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf-extras-conditionalcomments.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thymeleaf-extras-data-attribute.version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">thymeleaf-extras-data-attribute.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thymeleaf-extras-java8time.version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf-extras-java8time.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tomcat.version</span>&gt;</span>8.5.23<span class="tag">&lt;/<span class="name">tomcat.version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">...............</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- Spring Boot --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>test-jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>test-jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果在项目中引入了对应的依赖，那么这些依赖的版本就会是spring-boot-parent中定义的版本</p>
<p>Spring Boot提供了许多开箱即用的依赖模块，这些模块都是以spring-boot-starter-XX命名的。比如要开启Spring Boot的web功能，只需要在pom.xml中配置spring-boot-starter-web即可</p>
<p>因为其依赖于spring-boot-starter-parent，所以这里可以不用配置version。保存后Maven会自动帮我们下载spring-boot-starter-web模块所包含的jar文件。如果需要具体查看spring-boot-starter-web包含了哪些依赖</p>
<p>当然可以手动排除一些我们不想使用的依赖，可以使用如下方法<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><br>我们使用上面的方式排除了spring-boot-starter-web中的tomcat依赖，换成了使用jetty依赖</p>
<p>最后，配置了一个maven插件</p>
<p>spring-boot-maven-plugin为Spring Boot Maven插件，提供了：</p>
<ol>
<li><p>把项目打包成一个可执行的超级JAR（uber-JAR）,包括把应用程序的所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行应用程序。</p>
</li>
<li><p>搜索public static void main()方法来标记为可运行类。</p>
</li>
</ol>
<p>对于spring boot的简单介绍就到此为止，后面将一步一步深入继续介绍有关spring boot的内容</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title>看看七大排序算法吧</title>
    <url>/2018/09/06/ckybpqxgw0019d2nh666gevc6/</url>
    <content><![CDATA[<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>内部排序</p>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><ul>
<li>直接插入排序</li>
<li>希尔排序</li>
</ul>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><ul>
<li>简单选择排序</li>
<li>堆排序</li>
</ul>
<h5 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h5><ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
<a id="more"></a>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>给定一组序列，假定第一个记录自成一个有序序列，其余记录为无序序列。接着从第二个记录开始，按照记录的大小依此将当前处理的记录插入到其之前的有序序列中，直到最后一个记录插入到有序序列中为止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 假设第一个序列的第一个元素是有序的</span></span><br><span class="line">    <span class="comment">// 38，73，27，79，19，76</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length ==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2. 设置一个下标,从1开始（从第二个元素开始）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 当前元素和前一个比较</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">if</span>(temp &lt; arr[j=<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="comment">// 前一个比当前的大，则将当前元素放到合适的位置</span></span><br><span class="line">            <span class="comment">// 此处要找出当前元素合适的位置，同时把前面的元素向后移动</span></span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">while</span>(arr[j]&gt;temp &amp;&amp; j&gt;=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前：</span><br><span class="line"><span class="number">38</span>  <span class="number">65</span>  <span class="number">97</span>  <span class="number">76</span>  <span class="number">13</span>  <span class="number">27</span>  <span class="number">49</span>  </span><br><span class="line">排序后：</span><br><span class="line"><span class="number">13</span>  <span class="number">27</span>  <span class="number">38</span>  <span class="number">49</span>  <span class="number">65</span>  <span class="number">76</span>  <span class="number">97</span></span><br></pre></td></tr></table></figure>
<h4 id="希尔排序（最小增量排序）"><a href="#希尔排序（最小增量排序）" class="headerlink" title="希尔排序（最小增量排序）"></a>希尔排序（最小增量排序）</h4><p>算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="comment">// 初始化增量h = length/2,每循环一次增量h/2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h = length/<span class="number">2</span>;h&gt;<span class="number">0</span>;h=h/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// 对相差当前增量的元素排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length-h;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp ;</span><br><span class="line">            <span class="keyword">if</span>(arr[i+h]&lt;arr[i])&#123;</span><br><span class="line">                temp = arr[i+h];</span><br><span class="line">                arr[i+h] = arr[i];</span><br><span class="line">                arr[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前：</span><br><span class="line"><span class="number">38</span>  <span class="number">65</span>  <span class="number">97</span>  <span class="number">76</span>  <span class="number">13</span>  <span class="number">27</span>  <span class="number">49</span>  </span><br><span class="line">shell排序后：</span><br><span class="line"><span class="number">13</span>  <span class="number">27</span>  <span class="number">38</span>  <span class="number">49</span>  <span class="number">65</span>  <span class="number">76</span>  <span class="number">97</span></span><br></pre></td></tr></table></figure>
<h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>在要排序的一组数中，选出最小的一个数与第一个位置的数交换；</p>
<p>然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> minLocation = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 在序列中挑选出最小的一个数和第一个交换</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> temp = arr[i];  <span class="comment">// 最小的数</span></span><br><span class="line">			<span class="comment">// 遍历查找出最下的数</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(temp &gt; arr[j])&#123;</span><br><span class="line">					temp = arr[j];  <span class="comment">// temp 为最小的数</span></span><br><span class="line">					minLocation = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 到此，找出了本次循环最小的数和最小数的位置</span></span><br><span class="line">			<span class="comment">// 交换</span></span><br><span class="line">			<span class="keyword">if</span>(minLocation != i)&#123;</span><br><span class="line">				arr[minLocation] = arr[i];</span><br><span class="line">				arr[i] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前：</span><br><span class="line"><span class="number">38</span>  <span class="number">65</span>  <span class="number">97</span>  <span class="number">76</span>  <span class="number">13</span>  <span class="number">27</span>  <span class="number">49</span>  </span><br><span class="line">选择排序后：</span><br><span class="line"><span class="number">13</span>  <span class="number">27</span>  <span class="number">38</span>  <span class="number">49</span>  <span class="number">65</span>  <span class="number">76</span>  <span class="number">97</span></span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> temp  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 内部循环从序列末尾开始</span></span><br><span class="line">        <span class="keyword">for</span>(j = arr.length-<span class="number">1</span>;j&gt;i;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j-<span class="number">1</span>] &gt; arr[j])&#123;</span><br><span class="line">                <span class="comment">// 交换</span></span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前：</span><br><span class="line"><span class="number">38</span>  <span class="number">65</span>  <span class="number">97</span>  <span class="number">76</span>  <span class="number">13</span>  <span class="number">27</span>  <span class="number">49</span>  <span class="number">21</span>  <span class="number">5</span>  <span class="number">8</span>  <span class="number">6</span>  <span class="number">4</span>  <span class="number">8</span>  <span class="number">3</span>  <span class="number">9</span>  </span><br><span class="line">冒泡排序后：</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">13</span>  <span class="number">21</span>  <span class="number">27</span>  <span class="number">38</span>  <span class="number">49</span>  <span class="number">65</span>  <span class="number">76</span>  <span class="number">97</span></span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是一种非常高效的排算法，它采用了<code>分而治之</code>的思想，把大的拆成小的，小的再拆分为更小的</p>
<p>基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 选择基准元素，扫描一遍</span></span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">int</span> key = arr[low];   <span class="comment">// 选择基准元素</span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;i)&#123;</span><br><span class="line">        <span class="comment">/*if(arr[i]&gt;arr[j])&#123;</span></span><br><span class="line"><span class="comment">				//</span></span><br><span class="line"><span class="comment">			&#125;*/</span>   </span><br><span class="line">        <span class="comment">// 可能会出现连续的比关键字大的，就需要继续找,所以使用循环</span></span><br><span class="line">        <span class="comment">// 从后向前比较</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;i &amp;&amp; key &lt;= arr[j])&#123; <span class="comment">// 如果没有比关键字小的，则比较下一个，直到有比关键字小的交换位置</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出比关键字小的位置，交换两个位置的元素</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j]&lt;=key)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从前向后比较</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;i &amp;&amp; key &gt;= arr[i])&#123; <span class="comment">// 如果没有比关键字小的，则比较下一个，直到有比关键字小的交换位置</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;=key)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时第一次循环比较结束，</span></span><br><span class="line">    <span class="comment">//关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，</span></span><br><span class="line">    <span class="comment">//但是两边的顺序还有可能是不一样的，进行下面的递归调用</span></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    sort(arr, low, i-<span class="number">1</span>);</span><br><span class="line">    sort(arr,j+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前：</span><br><span class="line"><span class="number">38</span>  <span class="number">65</span>  <span class="number">97</span>  <span class="number">76</span>  <span class="number">13</span>  <span class="number">27</span>  <span class="number">49</span>  <span class="number">21</span>  <span class="number">5</span>  <span class="number">8</span>  <span class="number">6</span>  <span class="number">4</span>  <span class="number">8</span>  <span class="number">3</span>  <span class="number">9</span>  <span class="number">58</span>  <span class="number">66</span>  <span class="number">75</span>  <span class="number">22</span>  <span class="number">93</span>  <span class="number">91</span>  <span class="number">10</span>  </span><br><span class="line">冒泡排序后：</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">13</span>  <span class="number">21</span>  <span class="number">22</span>  <span class="number">27</span>  <span class="number">38</span>  <span class="number">49</span>  <span class="number">58</span>  <span class="number">65</span>  <span class="number">66</span>  <span class="number">75</span>  <span class="number">76</span>  <span class="number">91</span>  <span class="number">93</span>  <span class="number">97</span></span><br></pre></td></tr></table></figure>
<h4 id="并归排序"><a href="#并归排序" class="headerlink" title="并归排序"></a>并归排序</h4><p>并归排序的思想：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p>使用技术： <code>递归</code>和 <code>分治</code></p>
<p>先拆分再组合</p>
<p>并归时排序，采用双指针分别指向左半边和右半边，左半边的和有半边的比较大小，小的一边存入新的数组并自增</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, low, mid);  <span class="comment">//  左边</span></span><br><span class="line">        mergeSort(arr, mid+<span class="number">1</span>, high); <span class="comment">// 右边</span></span><br><span class="line">        merge(arr, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span> [high-low+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> left = low;</span><br><span class="line">    <span class="keyword">int</span> right = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexOfTemp = <span class="number">0</span>;   <span class="comment">// temp 数组中的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时左边数组的数为有序的</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=mid &amp;&amp; right&lt;=high)&#123;</span><br><span class="line">        <span class="comment">// 比较左右两个，找出小的放到temp中</span></span><br><span class="line">        <span class="keyword">if</span>(arr[left] &lt; arr[right])&#123;</span><br><span class="line">            temp[indexOfTemp++] = arr[left++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[indexOfTemp++] = arr[right++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= mid)&#123;</span><br><span class="line">        temp[indexOfTemp++] = arr[left++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right &lt;= high)&#123;</span><br><span class="line">        temp[indexOfTemp++] = arr[right++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp -&gt; arr</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">        arr[low + i] = temp[i]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前：</span><br><span class="line"><span class="number">58</span>  <span class="number">66</span>  <span class="number">75</span>  <span class="number">22</span>  <span class="number">93</span>  <span class="number">91</span>  <span class="number">10</span>  <span class="number">16</span>  <span class="number">52</span>  <span class="number">18</span>  <span class="number">90</span>  <span class="number">77</span>  <span class="number">44</span>  <span class="number">29</span>  </span><br><span class="line">并归排序后：</span><br><span class="line"><span class="number">10</span>  <span class="number">16</span>  <span class="number">18</span>  <span class="number">22</span>  <span class="number">29</span>  <span class="number">44</span>  <span class="number">52</span>  <span class="number">58</span>  <span class="number">66</span>  <span class="number">75</span>  <span class="number">77</span>  <span class="number">90</span>  <span class="number">91</span>  <span class="number">93</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法，排序</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存和数据一致性问题</title>
    <url>/2018/09/07/ckybpqxgx001cd2nh7r0308sh/</url>
    <content><![CDATA[<p>在现在的架构中，缓存由于其高并发和高性能的特性，已经被广泛使用。在读取缓存方面，道理都很简单，但是在更新缓存这点上，到底是先更新缓存还是先更新数据库，存在着争议。</p>
<p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案</p>
<a id="more"></a>
<h1 id="三种更新策略"><a href="#三种更新策略" class="headerlink" title="三种更新策略"></a>三种更新策略</h1><ul>
<li>先更新数据库，再更新缓存</li>
<li>先删除缓存，再更新数据库</li>
<li>先更新数据库，再删除缓存</li>
</ul>
<h2 id="1-先更新数据库，再更新缓存"><a href="#1-先更新数据库，再更新缓存" class="headerlink" title="1.先更新数据库，再更新缓存"></a>1.先更新数据库，再更新缓存</h2><p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。</p>
<p><strong>原因一（线程安全角度）</strong></p>
<p>同时有请求A和请求B进行更新操作，那么会出现</p>
<p>（1）线程A更新了数据库<br>（2）线程B更新了数据库<br>（3）线程B更新了缓存<br>（4）线程A更新了缓存</p>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<p><strong>原因二（业务场景角度）</strong></p>
<p>有如下两点：</p>
<p>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</p>
<p>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p>
<p>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。</p>
<h2 id="2-先删缓存，再更新数据库"><a href="#2-先删缓存，再更新数据库" class="headerlink" title="2. 先删缓存，再更新数据库"></a>2. 先删缓存，再更新数据库</h2><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>
<p>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库</p>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
<p>那么，<strong>如何解决呢？采用延时双删策略</strong></p>
<p>伪代码如下</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">        redis.del<span class="constructor">Key(<span class="params">key</span>)</span>;</span><br><span class="line">        db.update<span class="constructor">Data(<span class="params">data</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line">        redis.del<span class="constructor">Key(<span class="params">key</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>转化为中文描述就是</p>
<p>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存</p>
<p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。</p>
<p><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong></p>
<p>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p><strong>如果你用了mysql的读写分离架构怎么办？</strong></p>
<p>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<p>（1）请求A进行写操作，删除缓存<br>（2）请求A将数据写入数据库了，<br>（3）请求B查询缓存发现，缓存没有值<br>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值<br>（5）请求B将旧值写入缓存<br>（6）数据库完成主从同步，从库变为新值</p>
<p>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</p>
<p><strong>采用这种同步淘汰策略，吞吐量降低怎么办？</strong></p>
<p>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>
<p><strong>第二次删除,如果删除失败怎么办？</strong></p>
<p>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：</p>
<p>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>（6）请求A试图去删除请求B写入对缓存值，结果失败了。</p>
<p>ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。</p>
<p><strong>如何解决呢？</strong></p>
<p>具体解决方案，且看博主对第(3)种更新策略的解析。</p>
<h2 id="3-先更新数据库，再删缓存"><a href="#3-先更新数据库，再删缓存" class="headerlink" title="3. 先更新数据库，再删缓存"></a>3. 先更新数据库，再删缓存</h2><p>首先，先说一下。老外提出了一个缓存更新套路，名为《Cache-Aside pattern》。其中就指出</p>
<ul>
<li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</li>
<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<p>另外，知名社交网站facebook也在论文《Scaling Memcache at Facebook》中提出，他们用的也是先更新数据库，再删缓存的策略。</p>
<p><strong>这种情况不存在并发问题么？</strong></p>
<p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>
<p>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存</p>
<p>ok，如果发生上述情况，确实是会发生脏数据。</p>
<p><strong>然而，发生这种情况的概率又有多少呢？</strong></p>
<p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</p>
<p>假设，有人非要抬杠，有强迫症，一定要解决怎么办？</p>
<p><strong>如何解决上述并发问题？</strong></p>
<p>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。</p>
<p><strong>还有其他造成不一致的原因么？</strong></p>
<p>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。</p>
<p><strong>如何解决？</strong></p>
<p>提供一个保障的重试机制即可，这里给出两套方案。</p>
<p><strong>方案一</strong>：</p>
<p>如下图所示<br>流程如下所示<br>（1）更新数据库数据；<br>（2）缓存因为种种问题删除失败<br>（3）将需要删除的key发送至消息队列<br>（4）自己消费消息，获得需要删除的key<br>（5）继续重试删除操作，直到成功</p>
<p>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p>
<p><strong>方案二</strong>：<br>流程如下图所示：</p>
<p>（1）更新数据库数据<br>（2）数据库会将操作信息写入binlog日志当中<br>（3）订阅程序提取出所需要的数据以及key<br>（4）另起一段非业务代码，获得该信息<br>（5）尝试删除缓存操作，发现删除失败<br>（6）将这些信息发送至消息队列<br>（7）重新从消息队列中获得该数据，重试操作。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>缓存，数据库，分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识总结</title>
    <url>/2018/08/17/ckybpqxgy001dd2nh97uw83gs/</url>
    <content><![CDATA[<h4 id="OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="OSI与TCP/IP各层的结构与功能,都有哪些协议"></a>OSI与TCP/IP各层的结构与功能,都有哪些协议</h4><h5 id="三种模型"><a href="#三种模型" class="headerlink" title="三种模型"></a>三种模型</h5><p><img src="/2018/08/17/ckybpqxgy001dd2nh97uw83gs/OSI三种模型.png" alt=""></p>
<h5 id="五层模型对应的协议"><a href="#五层模型对应的协议" class="headerlink" title="五层模型对应的协议"></a>五层模型对应的协议</h5><a id="more"></a>
<p><img src="/2018/08/17/ckybpqxgy001dd2nh97uw83gs/OSI各层对应的网络协议.png" alt=""></p>
<p>简单介绍一下各层的作用</p>
<h5 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h5><p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文</p>
<h5 id="2-运输层"><a href="#2-运输层" class="headerlink" title="2. 运输层"></a>2. 运输层</h5><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<h5 id="运输层重要的两种协议"><a href="#运输层重要的两种协议" class="headerlink" title="运输层重要的两种协议"></a>运输层重要的两种协议</h5><ol>
<li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）</li>
</ol>
<h5 id="UDP-的主要特点"><a href="#UDP-的主要特点" class="headerlink" title="UDP 的主要特点"></a>UDP 的主要特点</h5><ol>
<li>UDP 是无连接的；</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li>
<li>UDP 是面向报文的；</li>
<li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信；</li>
<li>UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li>
</ol>
<h5 id="TCP-的主要特点"><a href="#TCP-的主要特点" class="headerlink" title="TCP 的主要特点"></a>TCP 的主要特点</h5><ol>
<li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li>
<li>每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；</li>
<li>TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li>
<li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>
<li>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>
</ol>
<h5 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h5><p><strong>网络层(network layer)负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>
<p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
<p>网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分株，能通过网络层中的路由器找到目的主机。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong></p>
<h5 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4. 数据链路层"></a>4. 数据链路层</h5><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装程帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h5 id="4-物理层"><a href="#4-物理层" class="headerlink" title="4. 物理层"></a>4. 物理层</h5><p>在物理层上所传送的数据单位是比特。 <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p>
<h4 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h4><h5 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1. 三次握手"></a>1. 三次握手</h5><h5 id="三次握手示意图"><a href="#三次握手示意图" class="headerlink" title="三次握手示意图"></a>三次握手示意图</h5><p><img src="/2018/08/17/ckybpqxgy001dd2nh97uw83gs/TCP三次握手.png" alt=""></p>
<p>简单解释</p>
<ul>
<li>客户端——&gt;发送带有 SYN 标志的数据包–一次握手——&gt;服务端</li>
<li>服务端——&gt;发送带有 SYN/ACK 标志的数据包–二次握手——&gt;客户端</li>
<li>客户端——&gt;发送带有带有 ACK 标志的数据包–三次握手——&gt;服务端</li>
</ul>
<h5 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h5><p>三次握手的目的是为了建立客户端和服务端的可靠通信连接，就是为了确认双方发送数据和接受数据都正常</p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常</p>
<h5 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2. 四次挥手"></a>2. 四次挥手</h5><h5 id="四次挥手简单示意图"><a href="#四次挥手简单示意图" class="headerlink" title="四次挥手简单示意图"></a>四次挥手简单示意图</h5><p><img src="/2018/08/17/ckybpqxgy001dd2nh97uw83gs/TCP四次挥手.png" alt=""></p>
<p>简单解释</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p><img src="/2018/08/17/ckybpqxgy001dd2nh97uw83gs/TCP和UDP的区别.png" alt=""></p>
<ul>
<li>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</li>
<li>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</li>
</ul>
<h4 id="TCP-如何保证可靠的传输"><a href="#TCP-如何保证可靠的传输" class="headerlink" title="TCP 如何保证可靠的传输"></a>TCP 如何保证可靠的传输</h4><ol>
<li>数据包排序</li>
<li>校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>停止等待协议</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h4 id="浏览器输入地址后到显示网页的过程"><a href="#浏览器输入地址后到显示网页的过程" class="headerlink" title="浏览器输入地址后到显示网页的过程"></a>浏览器输入地址后到显示网页的过程</h4><p><img src="/2018/08/17/ckybpqxgy001dd2nh97uw83gs/从URL到显示网页的过程.png" alt=""></p>
<h4 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h4><ul>
<li>1XX 系列<ul>
<li>指定客户端需要进行的某些动作，代表请求已经被接受，需要继续处理</li>
</ul>
</li>
<li>2XX系列<ul>
<li>200： 表示请求已成功，请求所希望的响应头或数据体将随此响应返回</li>
<li>201： 表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’</li>
<li>202： 服务器已接受请求，但尚未处理</li>
</ul>
</li>
<li>3XX系列<ul>
<li>代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。这系列中最常见的有301、302状态码。</li>
<li>301： 被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li>
<li>302： 请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求</li>
</ul>
</li>
<li>4XX系列<ul>
<li>表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码</li>
<li>401： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li>
<li>403： 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交</li>
<li>404： 请求失败，请求所希望得到的资源未被在服务器上发现</li>
</ul>
</li>
<li>5XX系列<ul>
<li>代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码</li>
<li>500： 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</li>
<li>503： 由于临时的服务器维护或者过载，服务器当前无法处理请求。通常，这个是暂时状态，一段时间会恢复</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap的实现原理</title>
    <url>/2018/08/18/ckybpqxic002pd2nhbctl73je/</url>
    <content><![CDATA[<p>HashMap是一个线程不安全的容器，当容量大于<code>总量*负载因子</code>发生扩容时可能会出现环形链表从而导致死循环</p>
<blockquote>
<p>扩容就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示</p>
</blockquote>
<p>因此引进了线程安全的容器<code>ConcurrentHashMap</code></p>
<a id="more"></a>
<p><code>ConcurrentHashMap</code>在JDK1.7 和 JDK1.8中的实现有所不同</p>
<h4 id="JDK1-7中的实现"><a href="#JDK1-7中的实现" class="headerlink" title="JDK1.7中的实现"></a>JDK1.7中的实现</h4><h5 id="先来看看1-7中数据结构实现的图示"><a href="#先来看看1-7中数据结构实现的图示" class="headerlink" title="先来看看1.7中数据结构实现的图示"></a>先来看看1.7中数据结构实现的图示</h5><p><img src="/2018/08/18/ckybpqxic002pd2nhbctl73je/ConcurrentHashMap1.7中数据结构.png" alt="img"></p>
<p>由图中可以看出ConcurrentHashMap是由<code>Segment数组</code>，<code>HashEntry数组</code>组成的。这里和<code>HashMap</code>一样,都是<code>数组+链表</code>的形式</p>
<p>ConcurrentHashMap采用了分段锁的技术，其中一个<code>Segement</code>就是一个Lock，其继承自<code>ReentrantLock</code>,这样当一个线程占用了锁访问一个<code>Segment</code>时，不会影响到其它的<code>Segment</code></p>
<p><code>Segment</code>数组的意义就是将一个大的table分成多个小的table来进行加锁，而一个Segment存储的是HashEntry数组+链表，这和HashMap的数据结构一致</p>
<ul>
<li><p>Segment的大小最多65536个，没有指定concurrencyLevel元素初始化，Segment的大小ssize默认为16</p>
</li>
<li><p>每一个Segment元素下的HashEntry的初始化也是按照位于运算来计算</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>所以，HashEntry数组的最小为2</p>
<p>​</p>
</li>
</ul>
<h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h5><p>ConcurrentHashMap的get方法在整个过程中都不需要加锁</p>
<p>执行<code>get</code>方法的时候，需要先将<code>key</code>通过<code>hash</code>之后定位到具体的<code>Segment</code>，然后再通过一次<code>hash</code>定位到具体的元素上。</p>
<p>注意：为了保证可见性,HashEntry中的 <code>value</code>属性使用了<code>volatile</code>修饰</p>
<h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h5><p>内部 <code>HashEntry</code> 类</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> HashEntry&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V value;</span><br><span class="line">       <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; <span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">       HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; <span class="keyword">next</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.<span class="keyword">next</span> = <span class="keyword">next</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>虽然 HashEntry 中的 value 是用 <code>volatile</code> 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理</p>
<p>首先也是通过 Key 的 Hash 定位到具体的 Segment，在 put 之前会进行一次扩容校验。</p>
<p>Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒。</p>
<h5 id="size-方法"><a href="#size-方法" class="headerlink" title="size 方法"></a>size 方法</h5><p>每一个<code>Segment</code>都有一个volatile修饰的全局变量<code>count</code>,要获取整个Map集合的size的时候，就需要获取每个Segment的count，然后累加起来。虽然<code>count</code>变量被<code>volatile</code>修饰符修饰，但这个不能保证操作的原子性，可能出现当获取size的时候还有其它线程在做插入操作。这样就引发了并发的问题</p>
<p>但是如果在获取size的时候将其它操作也加锁，这样就造成效率问题</p>
<p>所以解决的办法是：先尝试两次将<code>count</code>累加，当两次结果不一致时，才加锁来统计count</p>
<p><code>Councurrent</code> 中每一个<code>Segment</code>都包含一个<code>modCount</code>变量，每当进行一次添加/删除操作，<code>modCount</code>的值就会发生变化，只要<code>modCount</code>发生变化那么就认为容器大小也在发生变化</p>
<h4 id="JDK-1-8实现"><a href="#JDK-1-8实现" class="headerlink" title="JDK 1.8实现"></a>JDK 1.8实现</h4><h5 id="先来看看1-8中数据结构实现的图示"><a href="#先来看看1-8中数据结构实现的图示" class="headerlink" title="先来看看1.8中数据结构实现的图示"></a>先来看看1.8中数据结构实现的图示</h5><p><img src="/2018/08/18/ckybpqxic002pd2nhbctl73je/ConcurrentHashMap1.8中数据结构.png" alt="img"></p>
<p>JDK 1.8中的<code>ConcurrentHashMap</code>和1.7中的实现有着明显的差异</p>
<p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性.</p>
<p>采用了<code>Node数组+链表+红黑树</code>的数据结构来实现</p>
<h5 id="基本常量设计和数据结构"><a href="#基本常量设计和数据结构" class="headerlink" title="基本常量设计和数据结构"></a>基本常量设计和数据结构</h5><p>在深入了解JDK1.8中的<code>ConcurrentHashMap</code>前，先来了解一下基本常量和数据结构</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node数组最大容量：2^30=1073741824</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认初始值，必须是2的幕数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//数组可能最大值，需要与toArray（）相关方法关联</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//并发级别，遗留下来的，为兼容以前的版本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75</span>f;</span><br><span class="line"><span class="comment">// 链表转红黑树阀值,&gt; 8 链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 2^15-1，help resize的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 32-16=16，sizeCtl中记录size大小的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">// forwarding nodes的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; </span><br><span class="line"><span class="comment">// 树根节点的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; </span><br><span class="line"><span class="comment">// ReservationNode的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; </span><br><span class="line"><span class="comment">// 可用处理器数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = <span class="keyword">Runtime</span>.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">//存放node的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">/*控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义</span></span><br><span class="line"><span class="comment"> *当为负数时：-1代表正在初始化，-N代表有N-1个线程正在 进行扩容</span></span><br><span class="line"><span class="comment"> *当为0时：代表当时的table还没有被初始化</span></span><br><span class="line"><span class="comment"> *当为正数时：表示初始化或者下一次进行扩容的大小</span></span><br><span class="line"><span class="comment">private transient volatile int sizeCtl;</span></span><br></pre></td></tr></table></figure>
<h5 id="Node的数据结构"><a href="#Node的数据结构" class="headerlink" title="Node的数据结构"></a>Node的数据结构</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">K,V</span>&gt; <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="type">K,V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> int hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V <span class="keyword">val</span>;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V <span class="keyword">val</span>, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">val</span> = <span class="keyword">val</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K getKey()       &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V getValue()     &#123; <span class="keyword">return</span> <span class="keyword">val</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> int hashCode()   &#123; <span class="keyword">return</span> key.hashCode() ^ <span class="keyword">val</span>.hashCode(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String toString()&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + <span class="keyword">val</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V setValue(V value) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> boolean equals(Object o) &#123;</span><br><span class="line">            Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">            <span class="keyword">return</span> ((o instanceof Map.Entry) &amp;&amp;</span><br><span class="line">                    (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    (v = e.getValue()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                    (v == (u = <span class="keyword">val</span>) || v.equals(u)));</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//用于map中的get（）方法，子类重写</span></span><br><span class="line">        Node&lt;K,V&gt; find(int h, Object k) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    K ek;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                        ((ek = e.key) == k || (ek != <span class="literal">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TreeNode的数据结构"><a href="#TreeNode的数据结构" class="headerlink" title="TreeNode的数据结构"></a>TreeNode的数据结构</h5><p><code>TreeNode</code>继承与<code>Node</code>，但是数据结构换成了二叉树结构，它是<code>红黑树</code>的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于<code>8</code>时会转换成红黑树的结构，他就是通过TreeNode作为存储结构代替Node来转换成黑红树</p>
<p>红黑树数据结构源代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">static <span class="keyword">final</span> <span class="keyword">class</span> <span class="symbol">TreeNode</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt; <span class="symbol">extends</span> <span class="symbol">Node</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt; &#123;</span><br><span class="line">    <span class="comment">//树形结构的属性定义</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="built_in">bool</span>ean red; <span class="comment">//标志红黑树的红节点</span></span><br><span class="line">    TreeNode(<span class="built_in">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;K,V&gt; find(<span class="built_in">int</span> h, Object k) &#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key查找 从根节点开始找出相应的TreeNode，</span></span><br><span class="line">    <span class="keyword">final</span> TreeNode&lt;K,V&gt; findTreeNode(<span class="built_in">int</span> h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="built_in">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h5><p>我们通过ConcurrentHashMap的构造方法可以看出，在构造方法中并没有做初始化的事。初始化放到了put操作中，这是和其它集合由区别的地方</p>
<p><img src="/2018/08/18/ckybpqxic002pd2nhbctl73je/ConcurrentHashMap的构造方法.png" alt="img"></p>
<h5 id="put-操作过程"><a href="#put-操作过程" class="headerlink" title="put 操作过程"></a>put 操作过程</h5><p>查看put 方法</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">final V <span class="built_in">putVal</span>(K <span class="built_in">key</span>, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="built_in">null</span> || value == <span class="built_in">null</span>) throw <span class="keyword">new</span> <span class="built_in">NullPointerException</span>();</span><br><span class="line">    int hash = <span class="built_in">spread</span>(<span class="built_in">key</span>.<span class="built_in">hashCode</span>()); <span class="comment">//两次hash，减少hash冲突，可以均匀分布</span></span><br><span class="line">    int binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] <span class="built_in">tab</span> = table;;) &#123; //对这个table进行迭代</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        <span class="comment">//这里就是上面构造方法没有进行初始化，在这里进行判断，为null就调用initTable进行初始化，属于懒汉模式初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="built_in">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = <span class="built_in">initTable</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = <span class="built_in">tabAt</span>(<span class="built_in">tab</span>, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="built_in">null</span>) &#123;<span class="comment">//如果i位置没有数据，就直接无锁插入</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">casTabAt</span>(<span class="built_in">tab</span>, i, <span class="built_in">null</span>,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, <span class="built_in">key</span>, value, <span class="built_in">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">//如果在进行扩容，则先进行扩容操作</span></span><br><span class="line">            tab = <span class="built_in">helpTransfer</span>(<span class="built_in">tab</span>, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="built_in">null</span>;</span><br><span class="line">            <span class="comment">//如果以上条件都不满足，那就要进行加锁操作，也就是存在hash冲突，锁住链表或者红黑树的头结点</span></span><br><span class="line">            <span class="built_in">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tabAt</span>(<span class="built_in">tab</span>, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">//表示该节点是链表结构</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//这里涉及到相同的key进行put就会覆盖原先的value</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == <span class="built_in">key</span> ||</span><br><span class="line">                                 (ek != <span class="built_in">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="built_in">null</span>) &#123;  <span class="comment">//插入链表尾部</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                          value, <span class="built_in">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;<span class="comment">//红黑树结构</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//红黑树结构旋转插入</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).<span class="built_in">putTreeVal</span>(hash, <span class="built_in">key</span>,</span><br><span class="line">                                                       value)) != <span class="built_in">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; <span class="comment">//如果链表的长度大于8时就会进行红黑树的转换</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="built_in">treeifyBin</span>(<span class="built_in">tab</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="built_in">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">addCount</span>(<span class="number">1</span>L, binCount);<span class="comment">//统计size，并且检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put 操作可以描述为以下过程</p>
<ol>
<li>没有初始化就先调用initTable()方法初始化table数组</li>
<li>如果没有hash冲突就直接CAS插入</li>
<li>如果还在扩容就先进行扩容</li>
<li>如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入</li>
<li>最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，</li>
<li>如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容</li>
</ol>
<h5 id="initTable-方法"><a href="#initTable-方法" class="headerlink" title="initTable 方法"></a>initTable 方法</h5><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="keyword">tab</span>; int <span class="keyword">sc</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;<span class="comment">//空的table才能进入初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">sc</span> = sizeCtl) &lt; 0) <span class="comment">//sizeCtl&lt;0表示其他线程已经在初始化了或者扩容了，挂起当前线程 </span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, -1)) &#123;<span class="comment">//CAS操作SIZECTL为-1，表示初始化状态</span></span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">                    int <span class="keyword">n</span> = (<span class="keyword">sc</span> &gt; 0) ? <span class="keyword">sc</span> : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[<span class="keyword">n</span>];<span class="comment">//初始化</span></span><br><span class="line">                    <span class="keyword">table</span> = <span class="keyword">tab</span> = nt;</span><br><span class="line">                    <span class="keyword">sc</span> = <span class="keyword">n</span> - (<span class="keyword">n</span> &gt;&gt;&gt; 2);<span class="comment">//记录下次扩容的大小</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = <span class="keyword">sc</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">tab</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="get-操作过程"><a href="#get-操作过程" class="headerlink" title="get 操作过程"></a>get 操作过程</h5><p>ConcurrentHashMap的get操作的流程很简单，也很清晰，可以分为三个步骤来描述</p>
<ol>
<li>计算hash值，定位到该table索引位置，如果是首节点符合就返回</li>
<li>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</li>
<li>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</li>
</ol>
<h5 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h5><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">final <span class="keyword">long</span> <span class="title">sumCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    CounterCell[] <span class="keyword">as</span> = counterCells; CounterCell a; <span class="comment">//变化的数量</span></span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">as</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">as</span>.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = <span class="keyword">as</span>[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树</p>
<p>总结如下：</p>
<ol>
<li>JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）</li>
<li>JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了</li>
<li>JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基本操作</title>
    <url>/2019/01/27/ckybpqxid002sd2nhf9dlecze/</url>
    <content><![CDATA[<h1 id="Docker的基本操作"><a href="#Docker的基本操作" class="headerlink" title="Docker的基本操作"></a>Docker的基本操作</h1><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="Docker获取镜像"><a href="#Docker获取镜像" class="headerlink" title="Docker获取镜像"></a>Docker获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li><p>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</p>
</li>
<li><p>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</p>
<p>比如</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull ubuntu:16.04</span></span><br><span class="line">16.04: Pulling from library/ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image for ubuntu:16.04</span><br></pre></td></tr></table></figure>
<h3 id="Docker运行镜像"><a href="#Docker运行镜像" class="headerlink" title="Docker运行镜像"></a>Docker运行镜像</h3><p>有了镜像之后，可以在此基础上启动并运行，运行后的镜像称为容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm ubuntu:16.04 bash</span></span><br><span class="line"></span><br><span class="line">root@e7009c6ce357:/# cat /etc/os-release</span><br><span class="line">NAME="Ubuntu"</span><br><span class="line">VERSION="16.04.4 LTS, Trusty Tahr"</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME="Ubuntu 16.04.4 LTS"</span><br><span class="line">VERSION_ID="16.04"</span><br><span class="line">HOME_URL="http://www.ubuntu.com/"</span><br><span class="line">SUPPORT_URL="http://help.ubuntu.com/"</span><br><span class="line">BUG_REPORT_URL="http://bugs.launchpad.net/ubuntu/"</span><br></pre></td></tr></table></figure>
<p><code>docker run</code> 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:16.04</code>：这是指用 <code>ubuntu:16.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
<li>最后可以通过<code>exit</code>命令来退出容器</li>
</ul>
<h3 id="Docker列出镜像"><a href="#Docker列出镜像" class="headerlink" title="Docker列出镜像"></a>Docker列出镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tomcat              latest              7ee26c09afb3        3 days ago          462MB</span><br><span class="line">ubuntu              16.04               7e87e2b3bf7a        4 days ago          117MB</span><br><span class="line">hello-world         latest              fce289e99eb9        3 weeks ago         1.84kB</span><br></pre></td></tr></table></figure>
<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code> </p>
<p><strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个<strong>标签</strong> </p>
<h3 id="镜像体积问题"><a href="#镜像体积问题" class="headerlink" title="镜像体积问题"></a>镜像体积问题</h3><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:16.04</code> 镜像大小，在这里是 <code>127 MB</code>，但是在 <a href="https://hub.docker.com/r/library/ubuntu/tags/" target="_blank" rel="noopener">Docker Hub</a> 显示的却是 <code>50 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多</p>
<h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了节省空间，Docker会复用中间层镜像，而<code>docker image ls</code>只是显示了顶层镜像</p>
<p>如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure>
<h3 id="部分镜像查看"><a href="#部分镜像查看" class="headerlink" title="部分镜像查看"></a>部分镜像查看</h3><p><code>docker image ls</code>会列出所有的顶层镜像，如果只想查看特定镜像，可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls tomcat</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tomcat              latest              7ee26c09afb3        3 days ago          462MB</span><br></pre></td></tr></table></figure>
<p>还可以同时指定仓库和标签</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls ubuntu:16.04</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               7e87e2b3bf7a        4 days ago          117MB</span><br></pre></td></tr></table></figure>
<h3 id="Docker删除镜像"><a href="#Docker删除镜像" class="headerlink" title="Docker删除镜像"></a>Docker删除镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image rm 镜像1 [镜像2]</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。 </p>
<p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了 </p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tomcat              latest              7ee26c09afb3        3 days ago          462MB</span><br><span class="line">mysql               latest              71b5c7e10f9b        4 days ago          477MB</span><br><span class="line">ubuntu              16.04               7e87e2b3bf7a        4 days ago          117MB</span><br><span class="line">hello-world         latest              fce289e99eb9        3 weeks ago         1.84kB</span><br><span class="line">[root@localhost ~]# docker image rm 71b</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:048c2c616866c47c8a9fb604548d32ce842be292b56fba3d90fc07e0e143dac4</span><br><span class="line">Deleted: sha256:71b5c7e10f9b20f4bd37c348872899cac828b1d2edad269fc8b93c9d43682241</span><br><span class="line">Deleted: sha256:93b8c1c00d372509c6888231cb726e7b86967094de7ea52c937d15dd91950d0b</span><br><span class="line">Deleted: sha256:3837955eb61ec7c85d40ab07652700261d7bc2697f286473c8e06a685b72bd04</span><br><span class="line">Deleted: sha256:713ebd3c1007d105b495aea56622c280401fb7d546c446602b44c82db3f46426</span><br><span class="line">Deleted: sha256:cef5d1285d28d5f7cb4628be7583a817c97bdd7b15973e4238f8104558586ff5</span><br><span class="line">Deleted: sha256:f7aba53d045dded400e53bd3a206deebb0b238973528667d0b67a5acba7f0dd8</span><br><span class="line">Deleted: sha256:f7812c287bf837a8305e90fcda2f64780d6c78a08e29c344d8f88450b0c6f6c6</span><br><span class="line">Deleted: sha256:1ed10bc6753b7d6f1ef93f35f78c3ac288c703f4448b2af124f6aa1d8d0749fa</span><br><span class="line">Deleted: sha256:9e7275e8e159891e30790fb7fef26fb0bffbf93fb4ca9ec7c2188419e1bca50c</span><br><span class="line">Deleted: sha256:427ea12731646e109552c62208c34b89d7addadf83c7607a644325860ede8a70</span><br><span class="line">Deleted: sha256:2006fea1cac1ad9982a33fee5fc6776dc7c5c6aabe7f7a1842125c55566c9ce6</span><br><span class="line">Deleted: sha256:8e47708381224afca65fe791945667cc382aabe00c805f679a7136751aa6c3ad</span><br><span class="line">Deleted: sha256:3c816b4ead84066ec2cadec2b943993aaacc3fe35fcd77ada3d09dc4f3937313</span><br></pre></td></tr></table></figure>
<p>我们只用了ID的前3位就可以删除一个镜像</p>
<h3 id="Docker-commit"><a href="#Docker-commit" class="headerlink" title="Docker commit"></a>Docker commit</h3><p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成 </p>
<p>镜像是容器的基础，每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。接下来的几节就将讲解如何定制镜像 </p>
<p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的 </p>
<h4 id="pull-nginx"><a href="#pull-nginx" class="headerlink" title="pull nginx"></a>pull nginx</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker pull nginx</span><br><span class="line">Using<span class="built_in"> default </span>tag: latest</span><br><span class="line">latest: Pulling <span class="keyword">from</span> library/nginx</span><br><span class="line">5e6ec7f28fb7: Pull complete </span><br><span class="line">ab804f9bbcbe: Pull complete </span><br><span class="line">052b395f16bc: Pull complete </span><br><span class="line">Digest: sha256:56bcd35e8433343dbae0484ed5b740843dd8bff9479400990f251c13bbb94763</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> nginx:latest</span><br></pre></td></tr></table></figure>
<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker run --name webserver -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure>
<p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。 </p>
<p>如果我们想对这个容器做修改，可以进入容器内</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it webserver bash</span></span><br></pre></td></tr></table></figure>
<p>进入容器后，可以对文件做修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@3b9702b9719e:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@3b9702b9719e:/# cd /usr/share/nginx</span><br><span class="line">root@3b9702b9719e:/usr/share/nginx# ls</span><br><span class="line">html</span><br><span class="line">root@3b9702b9719e:/usr/share/nginx# echo '&lt;h1&gt;hello,ranger,this is nginx contianer on docker&lt;h1&gt;' &gt; html</span><br><span class="line">bash: html: Is a directory</span><br><span class="line">root@3b9702b9719e:/usr/share/nginx# echo '&lt;h1&gt;hello,ranger,this is nginx contianer on docker&lt;h1&gt;' &gt; html/index.html</span><br><span class="line">root@3b9702b9719e:/usr/share/nginx#</span><br></pre></td></tr></table></figure>
<p>重新访问就可以看到改变后的页面</p>
<p>改变了容器中的文件，可以查看这些改动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@3b9702b9719e:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@3b9702b9719e:/# cd /usr/share/nginx</span><br><span class="line">root@3b9702b9719e:/usr/share/nginx# ls</span><br><span class="line">html</span><br><span class="line">root@3b9702b9719e:/usr/share/nginx# echo '&lt;h1&gt;hello,ranger,this is nginx contianer on docker&lt;h1&gt;' &gt; html</span><br><span class="line">bash: html: Is a directory</span><br><span class="line">root@3b9702b9719e:/usr/share/nginx# echo '&lt;h1&gt;hello,ranger,this is nginx contianer on docker&lt;h1&gt;' &gt; html/index.html</span><br><span class="line">root@3b9702b9719e:/usr/share/nginx#</span><br></pre></td></tr></table></figure>
<p>加入我们现在想把这些改动保存成一个新的镜像，以后使用，就可以使用<code>docker commit</code></p>
<p><code>docker commit</code> 的语法格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure>
<p>现在查看有哪些镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">nginx               v2                  ac471dbf7f1f        About a minute ago   109MB</span><br><span class="line">tomcat              latest              7ee26c09afb3        3 days ago           462MB</span><br><span class="line">nginx               latest              42b4762643dc        4 days ago           109MB</span><br><span class="line">ubuntu              16.04               7e87e2b3bf7a        4 days ago           117MB</span><br><span class="line">hello-world         latest              fce289e99eb9        3 weeks ago          1.84kB</span><br></pre></td></tr></table></figure>
<h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><h3 id="Docker容器启动"><a href="#Docker容器启动" class="headerlink" title="Docker容器启动"></a>Docker容器启动</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>stopped</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器</p>
<h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>查看正在运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure>
<p>使用以下命令查看所有容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure>
<h3 id="新建并启动Docker"><a href="#新建并启动Docker" class="headerlink" title="新建并启动Docker"></a>新建并启动Docker</h3><p>所需要的命令主要为 <code>docker run</code>。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span><span class="bash"> ubuntu:14.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker run -t -i <span class="symbol">ubuntu:</span><span class="number">14.04</span> /bin/bash</span><br><span class="line">root<span class="variable">@af8bae53bdd3</span><span class="symbol">:/</span><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">root@<span class="symbol">af8bae53bdd3:</span>/<span class="comment"># pwd</span></span><br><span class="line">/</span><br><span class="line">root@<span class="symbol">af8bae53bdd3:</span>/<span class="comment"># ls</span></span><br><span class="line">bin boot dev etc home <span class="class"><span class="keyword">lib</span> <span class="title">lib64</span> <span class="title">media</span> <span class="title">mnt</span> <span class="title">opt</span> <span class="title">proc</span> <span class="title">root</span> <span class="title">run</span> <span class="title">sbin</span> <span class="title">srv</span> <span class="title">sys</span> <span class="title">tmp</span> <span class="title">usr</span> <span class="title">var</span></span></span><br></pre></td></tr></table></figure>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h3 id="启动已经终止的容器"><a href="#启动已经终止的容器" class="headerlink" title="启动已经终止的容器"></a>启动已经终止的容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。 </p>
<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><p>使用<code>docker container logs 容器</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker container logs 3b9</span><br><span class="line">192.168.25.1 - - [27/Jan/2019:06:26:01 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36" "-"</span><br><span class="line">2019/01/27 06:26:03 [error] 6#6: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 192.168.25.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "192.168.25.136", referrer: "http://192.168.25.136/"</span><br><span class="line">192.168.25.1 - - [27/Jan/2019:06:26:03 +0000] "GET /favicon.ico HTTP/1.1" 404 555 "http://192.168.25.136/" "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36" "-"</span><br><span class="line">192.168.25.1 - - [27/Jan/2019:06:29:54 +0000] "GET / HTTP/1.1" 200 55 "-" "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36" "-"</span><br></pre></td></tr></table></figure>
<h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>先查看正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">3b9702b9719e        nginx               "nginx -g 'daemon of…"   38 minutes ago      Up 29 minutes       0.0.0.0:80-&gt;80/tcp   webserver</span><br><span class="line">32e475d34375        tomcat              "catalina.sh run"        About an hour ago   Up 7 seconds        8080/tcp             compassionate_bardeen</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p>
<p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。 </p>
<h3 id="Docker进入容器"><a href="#Docker进入容器" class="headerlink" title="Docker进入容器"></a>Docker进入容器</h3><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台 </p>
<p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令 </p>
<h4 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a>attach命令</h4><p><code>docker attach</code> 是 Docker 自带的命令。下面示例如何使用该命令 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker attach 32e</span><br><span class="line">^C27-Jan-2019 06:58:42.095 INFO [Thread-5] org.apache.coyote.AbstractProtocol.pause Pausing ProtocolHandler ["http-nio-8080"]</span><br><span class="line">27-Jan-2019 06:58:42.306 INFO [Thread-5] org.apache.coyote.AbstractProtocol.pause Pausing ProtocolHandler ["ajp-nio-8009"]</span><br><span class="line">27-Jan-2019 06:58:42.318 INFO [Thread-5] org.apache.catalina.core.StandardService.stopInternal Stopping service [Catalina]</span><br><span class="line">27-Jan-2019 06:58:42.496 INFO [Thread-5] org.apache.coyote.AbstractProtocol.stop Stopping ProtocolHandler ["http-nio-8080"]</span><br><span class="line">27-Jan-2019 06:58:42.499 INFO [Thread-5] org.apache.coyote.AbstractProtocol.stop Stopping ProtocolHandler ["ajp-nio-8009"]</span><br><span class="line">27-Jan-2019 06:58:42.504 INFO [Thread-5] org.apache.coyote.AbstractProtocol.destroy Destroying ProtocolHandler ["http-nio-8080"]</span><br><span class="line">27-Jan-2019 06:58:42.505 INFO [Thread-5] org.apache.coyote.AbstractProtocol.destroy Destroying ProtocolHandler ["ajp-nio-8009"]</span><br></pre></td></tr></table></figure>
<p>进入容器后并停止了<code>tomcat</code>,<code>tomcat</code> 停止后，这个容器也就执行完了</p>
<h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h4><p> i -t 参数</p>
<p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -dit ubuntu</span><br><span class="line">4afc7ff447ac61e14242df8c2f8a26d8c54b8bee822dbfa2cd5340084b7e8e74</span><br><span class="line">[root@localhost ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">4afc7ff447ac        ubuntu              "/bin/bash"              21 seconds ago      Up 15 seconds                            blissful_wiles</span><br><span class="line">3b9702b9719e        nginx               "nginx -g 'daemon of…"   About an hour ago   Up 37 minutes       0.0.0.0:80-&gt;80/tcp   webserver</span><br><span class="line">32e475d34375        tomcat              "catalina.sh run"        About an hour ago   Up 3 minutes        8080/tcp             compassionate_bardeen</span><br><span class="line">[root@localhost ~]# docker exec -i 4a bash</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker exec -i 4a bash</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br></pre></td></tr></table></figure>
<p>如果使用<code>docker attach 4a</code>进入容器后，再使用 exit退出容器，将会导致容器的终止</p>
<p>但是，使用<code>docker exec -it 4a bash</code></p>
<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因 </p>
<h3 id="导入导出容器"><a href="#导入导出容器" class="headerlink" title="　导入导出容器"></a>　导入导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">3b9702b9719e        nginx               "nginx -g 'daemon of…"   About an hour ago   Up 45 minutes       0.0.0.0:80-&gt;80/tcp   webserver</span><br><span class="line">32e475d34375        tomcat              "catalina.sh run"        2 hours ago         Up 11 minutes       8080/tcp             compassionate_bardeen</span><br><span class="line">[root@localhost ~]# docker export 3b nginx.tar</span><br><span class="line">"docker export" requires exactly 1 argument.</span><br><span class="line">See 'docker export --help'.</span><br><span class="line"></span><br><span class="line">Usage:  docker export [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Export a container's filesystem as a tar archive</span><br><span class="line">[root@localhost ~]# docker export 3b &gt;  nginx.tar</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg  Git检出代码工作脚本  nginx.tar  original-ks.cfg</span><br></pre></td></tr></table></figure>
<p>可以把导出的镜像在导入为镜像</p>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像 </p>
<h3 id="Docker删除容器"><a href="#Docker删除容器" class="headerlink" title="Docker删除容器"></a>Docker删除容器</h3><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS                NAMES</span><br><span class="line">c507aac48152        ubuntu              "/bin/bash"              35 minutes ago      Exited (0) 35 minutes ago                              flamboyant_lovelace</span><br><span class="line">77a1908342b8        ubuntu              "bash"                   38 minutes ago      Exited (127) 37 minutes ago                            ecstatic_pike</span><br><span class="line">3b9702b9719e        nginx               "nginx -g 'daemon of…"   About an hour ago   Up About an hour                  0.0.0.0:80-&gt;80/tcp   webserver</span><br><span class="line">3c1ee95ddbfd        hello-world         "/hello"                 2 hours ago         Exited (0) 2 hours ago                                 confident_borg</span><br><span class="line">32e475d34375        tomcat              "catalina.sh run"        2 hours ago         Exited (143) About a minute ago                        compassionate_bardeen</span><br><span class="line">0955cc000279        tomcat              "-it"                    2 hours ago         Created                           8080/tcp             cocky_tesla</span><br><span class="line">cd725259b2b3        hello-world         "/hello"                 2 hours ago         Exited (0) 2 hours ago                                 reverent_knuth</span><br><span class="line">[root@localhost ~]# docker container rm c5</span><br><span class="line">c5</span><br><span class="line">[root@localhost ~]# docker container rm 77a  3c 32e 09 cd</span><br><span class="line">77a</span><br><span class="line">3c</span><br><span class="line">32e</span><br><span class="line">09</span><br><span class="line">cd</span><br><span class="line">[root@localhost ~]# docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">3b9702b9719e        nginx               "nginx -g 'daemon of…"   About an hour ago   Up About an hour    0.0.0.0:80-&gt;80/tcp   webserver</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>
<h3 id="清楚所有终止的容器"><a href="#清楚所有终止的容器" class="headerlink" title="清楚所有终止的容器"></a>清楚所有终止的容器</h3><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">container</span> prune</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上就是docker的基本操作，以后还会涉及到高级的部分</p>
</blockquote>
<blockquote>
<p>大部分参考自什么是<a href="http://www.funtl.com/zh/docs-docker/" target="_blank" rel="noopener">Docker</a>,在自己机器上验证了操作</p>
</blockquote>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker,容器</tag>
      </tags>
  </entry>
</search>
